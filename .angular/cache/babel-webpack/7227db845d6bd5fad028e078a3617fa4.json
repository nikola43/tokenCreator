{"ast":null,"code":"import { InjectionToken, Injectable, Optional, Inject, NgModule, EventEmitter, Component, ViewEncapsulation, ChangeDetectionStrategy, Input, Output, ElementRef, NgZone, ChangeDetectorRef, ViewChild, ViewContainerRef, forwardRef, Directive } from '@angular/core';\nimport { DateAdapter, MAT_DATE_LOCALE, NativeDateModule, MatNativeDateModule } from '@angular/material/core';\nimport { A11yModule } from '@angular/cdk/a11y';\nimport { OverlayConfig, Overlay, OverlayModule } from '@angular/cdk/overlay';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport { MatButtonModule } from '@angular/material/button';\nimport { MatDialog, MatDialogModule } from '@angular/material/dialog';\nimport { MatIconModule } from '@angular/material/icon';\nimport { ENTER, PAGE_DOWN, PAGE_UP, END, HOME, DOWN_ARROW, UP_ARROW, RIGHT_ARROW, LEFT_ARROW, ESCAPE } from '@angular/cdk/keycodes';\nimport { MatDatepickerIntl, MAT_DATEPICKER_SCROLL_STRATEGY } from '@angular/material/datepicker';\nimport { first } from 'rxjs/operators';\nimport { trigger, state, style, transition, animate, keyframes } from '@angular/animations';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { ComponentPortal } from '@angular/cdk/portal';\nimport { Subject, Subscription, of, merge } from 'rxjs';\nimport { NG_VALUE_ACCESSOR, NG_VALIDATORS, Validators } from '@angular/forms';\nimport { MAT_INPUT_VALUE_ACCESSOR } from '@angular/material/input';\nimport { MatFormField } from '@angular/material/form-field';\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/material/core';\nimport * as ɵngcc2 from '@angular/common';\nimport * as ɵngcc3 from '@angular/material/datepicker';\nimport * as ɵngcc4 from '@angular/material/icon';\nimport * as ɵngcc5 from '@angular/cdk/a11y';\nimport * as ɵngcc6 from '@angular/material/dialog';\nimport * as ɵngcc7 from '@angular/cdk/overlay';\nimport * as ɵngcc8 from '@angular/cdk/bidi';\nimport * as ɵngcc9 from '@angular/material/form-field';\nimport * as ɵngcc10 from '@angular/material/button';\nconst _c0 = [\"mat-datetimepicker-calendar-body\", \"\"];\n\nfunction MatDatetimepickerCalendarBody_tr_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"tr\", 2);\n    ɵngcc0.ɵɵelementStart(1, \"td\", 3);\n    ɵngcc0.ɵɵtext(2);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵattribute(\"colspan\", ctx_r0.numCols);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(ctx_r0.label);\n  }\n}\n\nfunction MatDatetimepickerCalendarBody_tr_1_td_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"td\", 7);\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵattribute(\"colspan\", ctx_r4._firstRowOffset);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate1(\" \", ctx_r4._firstRowOffset >= ctx_r4.labelMinRequiredCells ? ctx_r4.label : \"\", \" \");\n  }\n}\n\nfunction MatDatetimepickerCalendarBody_tr_1_td_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r9 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"td\", 8);\n    ɵngcc0.ɵɵlistener(\"click\", function MatDatetimepickerCalendarBody_tr_1_td_2_Template_td_click_0_listener() {\n      const restoredCtx = ɵngcc0.ɵɵrestoreView(_r9);\n      const item_r6 = restoredCtx.$implicit;\n      const ctx_r8 = ɵngcc0.ɵɵnextContext(2);\n      return ctx_r8._cellClicked(item_r6);\n    });\n    ɵngcc0.ɵɵelementStart(1, \"div\", 9);\n    ɵngcc0.ɵɵtext(2);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const item_r6 = ctx.$implicit;\n    const colIndex_r7 = ctx.index;\n    const rowIndex_r3 = ɵngcc0.ɵɵnextContext().index;\n    const ctx_r5 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵclassProp(\"mat-datetimepicker-calendar-body-active\", ctx_r5._isActiveCell(rowIndex_r3, colIndex_r7))(\"mat-datetimepicker-calendar-body-disabled\", !item_r6.enabled);\n    ɵngcc0.ɵɵattribute(\"aria-disabled\", !item_r6.enabled || null)(\"aria-label\", item_r6.ariaLabel);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵclassProp(\"mat-datetimepicker-calendar-body-selected\", ctx_r5.selectedValue === item_r6.value)(\"mat-datetimepicker-calendar-body-today\", ctx_r5.todayValue === item_r6.value);\n    ɵngcc0.ɵɵattribute(\"aria-selected\", ctx_r5.selectedValue === item_r6.value);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate1(\" \", item_r6.displayValue, \" \");\n  }\n}\n\nfunction MatDatetimepickerCalendarBody_tr_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"tr\", 4);\n    ɵngcc0.ɵɵtemplate(1, MatDatetimepickerCalendarBody_tr_1_td_1_Template, 2, 2, \"td\", 5);\n    ɵngcc0.ɵɵtemplate(2, MatDatetimepickerCalendarBody_tr_1_td_2_Template, 3, 12, \"td\", 6);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const row_r2 = ctx.$implicit;\n    const rowIndex_r3 = ctx.index;\n    const ctx_r1 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", rowIndex_r3 === 0 && ctx_r1._firstRowOffset);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngForOf\", row_r2);\n  }\n}\n\nfunction MatDatetimepickerCalendar_div_1_mat_icon_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"mat-icon\");\n    ɵngcc0.ɵɵtext(1, \"arrow_drop_down\");\n    ɵngcc0.ɵɵelementEnd();\n  }\n}\n\nfunction MatDatetimepickerCalendar_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r10 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"div\", 10);\n    ɵngcc0.ɵɵlistener(\"click\", function MatDatetimepickerCalendar_div_1_Template_div_click_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r10);\n      const ctx_r9 = ɵngcc0.ɵɵnextContext();\n      return ctx_r9._yearClicked();\n    });\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵtemplate(2, MatDatetimepickerCalendar_div_1_mat_icon_2_Template, 2, 0, \"mat-icon\", 11);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵclassProp(\"active\", ctx_r0.currentView === \"year\" || ctx_r0.currentView === \"multi-year\");\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate1(\"\", ctx_r0._yearLabel, \" \");\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r0.multiYearSelector || ctx_r0.type === \"year\");\n  }\n}\n\nfunction MatDatetimepickerCalendar_span_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r12 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"span\", 12);\n    ɵngcc0.ɵɵlistener(\"click\", function MatDatetimepickerCalendar_span_3_Template_span_click_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r12);\n      const ctx_r11 = ɵngcc0.ɵɵnextContext();\n      return ctx_r11._dateClicked();\n    });\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵclassProp(\"active\", ctx_r1.currentView === \"month\")(\"not-clickable\", ctx_r1.type === \"month\");\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(ctx_r1._dateLabel);\n  }\n}\n\nfunction MatDatetimepickerCalendar_span_4_span_7_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r15 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"span\", 17);\n    ɵngcc0.ɵɵelementStart(1, \"span\", 18);\n    ɵngcc0.ɵɵlistener(\"click\", function MatDatetimepickerCalendar_span_4_span_7_Template_span_click_1_listener() {\n      ɵngcc0.ɵɵrestoreView(_r15);\n      const ctx_r14 = ɵngcc0.ɵɵnextContext(2);\n      return ctx_r14._ampmClicked(\"AM\");\n    });\n    ɵngcc0.ɵɵtext(2, \"AM\");\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵtext(3, \"/\");\n    ɵngcc0.ɵɵelementStart(4, \"span\", 18);\n    ɵngcc0.ɵɵlistener(\"click\", function MatDatetimepickerCalendar_span_4_span_7_Template_span_click_4_listener() {\n      ɵngcc0.ɵɵrestoreView(_r15);\n      const ctx_r16 = ɵngcc0.ɵɵnextContext(2);\n      return ctx_r16._ampmClicked(\"PM\");\n    });\n    ɵngcc0.ɵɵtext(5, \"PM\");\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r13 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵclassProp(\"active\", ctx_r13._AMPM === \"AM\");\n    ɵngcc0.ɵɵadvance(3);\n    ɵngcc0.ɵɵclassProp(\"active\", ctx_r13._AMPM === \"PM\");\n  }\n}\n\nfunction MatDatetimepickerCalendar_span_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r18 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"span\", 13);\n    ɵngcc0.ɵɵelementStart(1, \"span\", 14);\n    ɵngcc0.ɵɵlistener(\"click\", function MatDatetimepickerCalendar_span_4_Template_span_click_1_listener() {\n      ɵngcc0.ɵɵrestoreView(_r18);\n      const ctx_r17 = ɵngcc0.ɵɵnextContext();\n      return ctx_r17._hoursClicked();\n    });\n    ɵngcc0.ɵɵtext(2);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵtext(3, \":\");\n    ɵngcc0.ɵɵelementStart(4, \"span\", 15);\n    ɵngcc0.ɵɵlistener(\"click\", function MatDatetimepickerCalendar_span_4_Template_span_click_4_listener() {\n      ɵngcc0.ɵɵrestoreView(_r18);\n      const ctx_r19 = ɵngcc0.ɵɵnextContext();\n      return ctx_r19._minutesClicked();\n    });\n    ɵngcc0.ɵɵtext(5);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelement(6, \"br\");\n    ɵngcc0.ɵɵtemplate(7, MatDatetimepickerCalendar_span_4_span_7_Template, 6, 4, \"span\", 16);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵclassProp(\"active\", ctx_r2.currentView === \"clock\");\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵclassProp(\"active\", ctx_r2._clockView == \"hour\");\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(ctx_r2._hoursLabel);\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵclassProp(\"active\", ctx_r2._clockView == \"minute\");\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(ctx_r2._minutesLabel);\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r2.twelvehour);\n  }\n}\n\nfunction MatDatetimepickerCalendar_div_6_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r21 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"div\", 19);\n    ɵngcc0.ɵɵelementStart(1, \"div\", 20);\n    ɵngcc0.ɵɵelementStart(2, \"div\", 21);\n    ɵngcc0.ɵɵlistener(\"click\", function MatDatetimepickerCalendar_div_6_Template_div_click_2_listener() {\n      ɵngcc0.ɵɵrestoreView(_r21);\n      const ctx_r20 = ɵngcc0.ɵɵnextContext();\n      return ctx_r20._previousClicked();\n    });\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelementStart(3, \"svg\", 22);\n    ɵngcc0.ɵɵelement(4, \"path\", 23);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵnamespaceHTML();\n    ɵngcc0.ɵɵelementStart(5, \"div\", 24);\n    ɵngcc0.ɵɵlistener(\"@slideCalendar.done\", function MatDatetimepickerCalendar_div_6_Template_div_animation_slideCalendar_done_5_listener() {\n      ɵngcc0.ɵɵrestoreView(_r21);\n      const ctx_r22 = ɵngcc0.ɵɵnextContext();\n      return ctx_r22._calendarStateDone();\n    });\n    ɵngcc0.ɵɵelementStart(6, \"strong\");\n    ɵngcc0.ɵɵtext(7);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementStart(8, \"div\", 25);\n    ɵngcc0.ɵɵlistener(\"click\", function MatDatetimepickerCalendar_div_6_Template_div_click_8_listener() {\n      ɵngcc0.ɵɵrestoreView(_r21);\n      const ctx_r23 = ɵngcc0.ɵɵnextContext();\n      return ctx_r23._nextClicked();\n    });\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelementStart(9, \"svg\", 22);\n    ɵngcc0.ɵɵelement(10, \"path\", 26);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵclassProp(\"disabled\", !ctx_r3._previousEnabled());\n    ɵngcc0.ɵɵattribute(\"aria-disabled\", !ctx_r3._previousEnabled())(\"aria-label\", ctx_r3._ariaLabelPrev);\n    ɵngcc0.ɵɵadvance(3);\n    ɵngcc0.ɵɵproperty(\"@slideCalendar\", ctx_r3._calendarState);\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵtextInterpolate(ctx_r3._monthYearLabel);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵclassProp(\"disabled\", !ctx_r3._nextEnabled());\n    ɵngcc0.ɵɵattribute(\"aria-disabled\", !ctx_r3._nextEnabled())(\"aria-label\", ctx_r3._ariaLabelNext);\n  }\n}\n\nfunction MatDatetimepickerCalendar_mat_datetimepicker_month_view_7_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r25 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"mat-datetimepicker-month-view\", 27);\n    ɵngcc0.ɵɵlistener(\"_userSelection\", function MatDatetimepickerCalendar_mat_datetimepicker_month_view_7_Template_mat_datetimepicker_month_view__userSelection_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r25);\n      const ctx_r24 = ɵngcc0.ɵɵnextContext();\n      return ctx_r24._userSelected();\n    })(\"selectedChange\", function MatDatetimepickerCalendar_mat_datetimepicker_month_view_7_Template_mat_datetimepicker_month_view_selectedChange_0_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r25);\n      const ctx_r26 = ɵngcc0.ɵɵnextContext();\n      return ctx_r26._dateSelected($event);\n    });\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"activeDate\", ctx_r4._activeDate)(\"dateFilter\", ctx_r4._dateFilterForViews)(\"selected\", ctx_r4.selected)(\"type\", ctx_r4.type);\n  }\n}\n\nfunction MatDatetimepickerCalendar_mat_datetimepicker_year_view_8_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r28 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"mat-datetimepicker-year-view\", 27);\n    ɵngcc0.ɵɵlistener(\"_userSelection\", function MatDatetimepickerCalendar_mat_datetimepicker_year_view_8_Template_mat_datetimepicker_year_view__userSelection_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r28);\n      const ctx_r27 = ɵngcc0.ɵɵnextContext();\n      return ctx_r27._userSelected();\n    })(\"selectedChange\", function MatDatetimepickerCalendar_mat_datetimepicker_year_view_8_Template_mat_datetimepicker_year_view_selectedChange_0_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r28);\n      const ctx_r29 = ɵngcc0.ɵɵnextContext();\n      return ctx_r29._monthSelected($event);\n    });\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r5 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"activeDate\", ctx_r5._activeDate)(\"dateFilter\", ctx_r5._dateFilterForViews)(\"selected\", ctx_r5.selected)(\"type\", ctx_r5.type);\n  }\n}\n\nfunction MatDatetimepickerCalendar_mat_datetimepicker_multi_year_view_9_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r31 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"mat-datetimepicker-multi-year-view\", 28);\n    ɵngcc0.ɵɵlistener(\"_userSelection\", function MatDatetimepickerCalendar_mat_datetimepicker_multi_year_view_9_Template_mat_datetimepicker_multi_year_view__userSelection_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r31);\n      const ctx_r30 = ɵngcc0.ɵɵnextContext();\n      return ctx_r30._userSelected();\n    })(\"selectedChange\", function MatDatetimepickerCalendar_mat_datetimepicker_multi_year_view_9_Template_mat_datetimepicker_multi_year_view_selectedChange_0_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r31);\n      const ctx_r32 = ɵngcc0.ɵɵnextContext();\n      return ctx_r32._yearSelected($event);\n    });\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r6 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"activeDate\", ctx_r6._activeDate)(\"dateFilter\", ctx_r6._dateFilterForViews)(\"maxDate\", ctx_r6.maxDate)(\"minDate\", ctx_r6.minDate)(\"selected\", ctx_r6.selected)(\"type\", ctx_r6.type);\n  }\n}\n\nfunction MatDatetimepickerCalendar_mat_datetimepicker_clock_10_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r34 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"mat-datetimepicker-clock\", 29);\n    ɵngcc0.ɵɵlistener(\"_userSelection\", function MatDatetimepickerCalendar_mat_datetimepicker_clock_10_Template_mat_datetimepicker_clock__userSelection_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r34);\n      const ctx_r33 = ɵngcc0.ɵɵnextContext();\n      return ctx_r33._userSelected();\n    })(\"activeDateChange\", function MatDatetimepickerCalendar_mat_datetimepicker_clock_10_Template_mat_datetimepicker_clock_activeDateChange_0_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r34);\n      const ctx_r35 = ɵngcc0.ɵɵnextContext();\n      return ctx_r35._onActiveDateChange($event);\n    })(\"selectedChange\", function MatDatetimepickerCalendar_mat_datetimepicker_clock_10_Template_mat_datetimepicker_clock_selectedChange_0_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r34);\n      const ctx_r36 = ɵngcc0.ɵɵnextContext();\n      return ctx_r36._timeSelected($event);\n    });\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r7 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"dateFilter\", ctx_r7.dateFilter)(\"interval\", ctx_r7.timeInterval)(\"maxDate\", ctx_r7.maxDate)(\"minDate\", ctx_r7.minDate)(\"selected\", ctx_r7._activeDate)(\"startView\", ctx_r7._clockView)(\"twelvehour\", ctx_r7.twelvehour);\n  }\n}\n\nfunction MatDatetimepickerClock_div_4_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"div\", 7);\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const item_r2 = ctx.$implicit;\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵstyleProp(\"font-size\", item_r2.fontSize)(\"left\", item_r2.left + \"%\")(\"top\", item_r2.top + \"%\");\n    ɵngcc0.ɵɵclassProp(\"mat-datetimepicker-clock-cell-disabled\", !item_r2.enabled)(\"mat-datetimepicker-clock-cell-selected\", ctx_r0._selectedHour == item_r2.value);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(item_r2.displayValue);\n  }\n}\n\nfunction MatDatetimepickerClock_div_6_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"div\", 7);\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const item_r3 = ctx.$implicit;\n    const ctx_r1 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵstyleProp(\"left\", item_r3.left + \"%\")(\"top\", item_r3.top + \"%\");\n    ɵngcc0.ɵɵclassProp(\"mat-datetimepicker-clock-cell-disabled\", !item_r3.enabled)(\"mat-datetimepicker-clock-cell-selected\", ctx_r1._selectedMinute == item_r3.value);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(item_r3.displayValue);\n  }\n}\n\nfunction MatDatetimepickerToggle__svg_svg_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelementStart(0, \"svg\", 4);\n    ɵngcc0.ɵɵelement(1, \"path\", 5);\n    ɵngcc0.ɵɵelementEnd();\n  }\n}\n\nfunction MatDatetimepickerToggle__svg_svg_3_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelementStart(0, \"svg\", 4);\n    ɵngcc0.ɵɵelement(1, \"path\", 6);\n    ɵngcc0.ɵɵelementEnd();\n  }\n}\n\nfunction MatDatetimepickerToggle__svg_svg_4_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelementStart(0, \"svg\", 4);\n    ɵngcc0.ɵɵelement(1, \"path\", 7);\n    ɵngcc0.ɵɵelement(2, \"path\", 8);\n    ɵngcc0.ɵɵelementEnd();\n  }\n}\n\nfunction MatDatetimepickerMonthView_th_3_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"th\");\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const day_r1 = ctx.$implicit;\n    ɵngcc0.ɵɵattribute(\"aria-label\", day_r1.long);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(day_r1.narrow);\n  }\n}\n\nclass DatetimeAdapter extends DateAdapter {\n  constructor(_delegate) {\n    super();\n    this._delegate = _delegate;\n  }\n\n  getValidDateOrNull(obj) {\n    return this.isDateInstance(obj) && this.isValid(obj) ? obj : null;\n  }\n\n  compareDatetime(first, second, respectMinutePart = true) {\n    return this.compareDate(first, second) || this.getHour(first) - this.getHour(second) || respectMinutePart && this.getMinute(first) - this.getMinute(second);\n  }\n\n  sameDatetime(first, second) {\n    if (first && second) {\n      const firstValid = this.isValid(first);\n      const secondValid = this.isValid(second);\n\n      if (firstValid && secondValid) {\n        return !this.compareDatetime(first, second);\n      }\n\n      return firstValid === secondValid;\n    }\n\n    return first === second;\n  }\n\n  sameYear(first, second) {\n    return first && second && this.getYear(first) === this.getYear(second);\n  }\n\n  sameDay(first, second) {\n    return first && second && this.getDate(first) === this.getDate(second) && this.sameMonthAndYear(first, second);\n  }\n\n  sameHour(first, second) {\n    return first && second && this.getHour(first) === this.getHour(second) && this.sameDay(first, second);\n  }\n\n  sameMinute(first, second) {\n    return first && second && this.getMinute(first) === this.getMinute(second) && this.sameHour(first, second);\n  }\n\n  sameMonthAndYear(first, second) {\n    if (first && second) {\n      const firstValid = this.isValid(first);\n      const secondValid = this.isValid(second);\n\n      if (firstValid && secondValid) {\n        return !(this.getYear(first) - this.getYear(second) || this.getMonth(first) - this.getMonth(second));\n      }\n\n      return firstValid === secondValid;\n    }\n\n    return first === second;\n  } // delegate\n\n\n  clone(date) {\n    return this._delegate.clone(date);\n  }\n\n  addCalendarYears(date, years) {\n    return this._delegate.addCalendarYears(date, years);\n  }\n\n  addCalendarMonths(date, months) {\n    return this._delegate.addCalendarMonths(date, months);\n  }\n\n  addCalendarDays(date, days) {\n    return this._delegate.addCalendarDays(date, days);\n  }\n\n  getYear(date) {\n    return this._delegate.getYear(date);\n  }\n\n  getMonth(date) {\n    return this._delegate.getMonth(date);\n  }\n\n  getDate(date) {\n    return this._delegate.getDate(date);\n  }\n\n  getDayOfWeek(date) {\n    return this._delegate.getDayOfWeek(date);\n  }\n\n  getMonthNames(style) {\n    return this._delegate.getMonthNames(style);\n  }\n\n  getDateNames() {\n    return this._delegate.getDateNames();\n  }\n\n  getDayOfWeekNames(style) {\n    return this._delegate.getDayOfWeekNames(style);\n  }\n\n  getYearName(date) {\n    return this._delegate.getYearName(date);\n  }\n\n  getFirstDayOfWeek() {\n    return this._delegate.getFirstDayOfWeek();\n  }\n\n  getNumDaysInMonth(date) {\n    return this._delegate.getNumDaysInMonth(date);\n  }\n\n  createDate(year, month, date) {\n    return this._delegate.createDate(year, month, date);\n  }\n\n  today() {\n    return this._delegate.today();\n  }\n\n  parse(value, parseFormat) {\n    return this._delegate.parse(value, parseFormat);\n  }\n\n  format(date, displayFormat) {\n    return this._delegate.format(date, displayFormat);\n  }\n\n  toIso8601(date) {\n    return this._delegate.toIso8601(date);\n  }\n\n  isDateInstance(obj) {\n    return this._delegate.isDateInstance(obj);\n  }\n\n  isValid(date) {\n    return this._delegate.isValid(date);\n  }\n\n  invalid() {\n    return this._delegate.invalid();\n  }\n\n  clampDate(date, min, max) {\n    if (min && this.compareDatetime(date, min) < 0) {\n      return min;\n    }\n\n    if (max && this.compareDatetime(date, max) > 0) {\n      return max;\n    }\n\n    return date;\n  }\n\n}\n\nconst MAT_DATETIME_FORMATS = new InjectionToken(\"mat-datetime-formats\");\n\nconst ɵ0$1 = i => String(i);\n/** The default hour names to use if Intl API is not available. */\n\n\nconst DEFAULT_HOUR_NAMES = range(24, ɵ0$1);\n\nconst ɵ1 = i => String(i);\n/** The default minute names to use if Intl API is not available. */\n\n\nconst DEFAULT_MINUTE_NAMES = range(60, ɵ1);\n\nfunction range(length, valueFunction) {\n  const valuesArray = Array(length);\n\n  for (let i = 0; i < length; i++) {\n    valuesArray[i] = valueFunction(i);\n  }\n\n  return valuesArray;\n}\n\nlet NativeDatetimeAdapter = /*#__PURE__*/(() => {\n  class NativeDatetimeAdapter extends DatetimeAdapter {\n    constructor(matDateLocale, _delegate) {\n      super(_delegate);\n      this.setLocale(matDateLocale);\n    }\n\n    clone(date) {\n      return this.createDatetime(this.getYear(date), this.getMonth(date), this.getDate(date), this.getHour(date), this.getMinute(date));\n    }\n\n    getHour(date) {\n      return date.getHours();\n    }\n\n    getMinute(date) {\n      return date.getMinutes();\n    }\n\n    isInNextMonth(startDate, endDate) {\n      const nextMonth = this.getDateInNextMonth(startDate);\n      return this.sameMonthAndYear(nextMonth, endDate);\n    }\n\n    createDatetime(year, month, date, hour, minute) {\n      // Check for invalid month and date (except upper bound on date which we have to check after\n      // creating the Date).\n      if (month < 0 || month > 11) {\n        throw Error(`Invalid month index \"${month}\". Month index has to be between 0 and 11.`);\n      }\n\n      if (date < 1) {\n        throw Error(`Invalid date \"${date}\". Date has to be greater than 0.`);\n      }\n\n      if (hour < 0 || hour > 23) {\n        throw Error(`Invalid hour \"${hour}\". Hour has to be between 0 and 23.`);\n      }\n\n      if (minute < 0 || minute > 59) {\n        throw Error(`Invalid minute \"${minute}\". Minute has to be between 0 and 59.`);\n      }\n\n      const result = this._createDateWithOverflow(year, month, date, hour, minute); // Check that the date wasn't above the upper bound for the month, causing the month to overflow\n\n\n      if (result.getMonth() !== month) {\n        throw Error(`Invalid date \"${date}\" for month with index \"${month}\".`);\n      }\n\n      return result;\n    }\n\n    getFirstDateOfMonth(date) {\n      const result = new Date();\n      result.setFullYear(date.getFullYear(), date.getMonth(), 1);\n      return result;\n    }\n\n    getHourNames() {\n      return DEFAULT_HOUR_NAMES;\n    }\n\n    getMinuteNames() {\n      return DEFAULT_MINUTE_NAMES;\n    }\n\n    addCalendarYears(date, years) {\n      return this.addCalendarMonths(date, years * 12);\n    }\n\n    addCalendarMonths(date, months) {\n      let newDate = this._createDateWithOverflow(this.getYear(date), this.getMonth(date) + months, this.getDate(date), this.getHour(date), this.getMinute(date)); // It's possible to wind up in the wrong month if the original month has more days than the new\n      // month. In this case we want to go to the last day of the desired month.\n      // Note: the additional + 12 % 12 ensures we end up with a positive number, since JS % doesn't\n      // guarantee this.\n\n\n      if (this.getMonth(newDate) !== ((this.getMonth(date) + months) % 12 + 12) % 12) {\n        newDate = this._createDateWithOverflow(this.getYear(newDate), this.getMonth(newDate), 0, this.getHour(date), this.getMinute(date));\n      }\n\n      return newDate;\n    }\n\n    addCalendarDays(date, days) {\n      return this._createDateWithOverflow(this.getYear(date), this.getMonth(date), this.getDate(date) + days, this.getHour(date), this.getMinute(date));\n    }\n\n    addCalendarHours(date, hours) {\n      return this._createDateWithOverflow(this.getYear(date), this.getMonth(date), this.getDate(date), this.getHour(date) + hours, this.getMinute(date));\n    }\n\n    addCalendarMinutes(date, minutes) {\n      return this._createDateWithOverflow(this.getYear(date), this.getMonth(date), this.getDate(date), this.getHour(date), this.getMinute(date) + minutes);\n    }\n\n    toIso8601(date) {\n      return super.toIso8601(date) + \"T\" + [this._2digit(date.getUTCHours()), this._2digit(date.getUTCMinutes())].join(\":\");\n    }\n\n    getDateInNextMonth(date) {\n      return new Date(date.getFullYear(), date.getMonth() + 1, 1, date.getHours(), date.getMinutes());\n    }\n    /**\r\n     * Strip out unicode LTR and RTL characters. Edge and IE insert these into formatted dates while\r\n     * other browsers do not. We remove them to make output consistent and because they interfere with\r\n     * date parsing.\r\n     * @param str The string to strip direction characters from.\r\n     * @returns The stripped string.\r\n     */\n\n\n    _stripDirectionalityCharacters(str) {\n      return str.replace(/[\\u200e\\u200f]/g, \"\");\n    }\n    /**\r\n     * Pads a number to make it two digits.\r\n     * @param n The number to pad.\r\n     * @returns The padded number.\r\n     */\n\n\n    _2digit(n) {\n      return (\"00\" + n).slice(-2);\n    }\n    /** Creates a date but allows the month and date to overflow. */\n\n\n    _createDateWithOverflow(year, month, date, hours, minutes) {\n      const result = new Date(year, month, date, hours, minutes); // We need to correct for the fact that JS native Date treats years in range [0, 99] as\n      // abbreviations for 19xx.\n\n      if (year >= 0 && year < 100) {\n        result.setFullYear(this.getYear(result) - 1900);\n      }\n\n      return result;\n    }\n\n  }\n\n  NativeDatetimeAdapter.ɵfac = function NativeDatetimeAdapter_Factory(t) {\n    return new (t || NativeDatetimeAdapter)(ɵngcc0.ɵɵinject(MAT_DATE_LOCALE, 8), ɵngcc0.ɵɵinject(ɵngcc1.DateAdapter));\n  };\n\n  NativeDatetimeAdapter.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: NativeDatetimeAdapter,\n    factory: NativeDatetimeAdapter.ɵfac\n  });\n  /** @nocollapse */\n\n  return NativeDatetimeAdapter;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst MAT_NATIVE_DATETIME_FORMATS = {\n  parse: {},\n  display: {\n    dateInput: {\n      year: \"numeric\",\n      month: \"2-digit\",\n      day: \"2-digit\"\n    },\n    monthInput: {\n      month: \"long\"\n    },\n    datetimeInput: {\n      year: \"numeric\",\n      month: \"2-digit\",\n      day: \"2-digit\",\n      hour: \"2-digit\",\n      minute: \"2-digit\"\n    },\n    timeInput: {\n      hour: \"2-digit\",\n      minute: \"2-digit\"\n    },\n    monthYearLabel: {\n      year: \"numeric\",\n      month: \"short\"\n    },\n    dateA11yLabel: {\n      year: \"numeric\",\n      month: \"long\",\n      day: \"numeric\"\n    },\n    monthYearA11yLabel: {\n      year: \"numeric\",\n      month: \"long\"\n    },\n    popupHeaderDateLabel: {\n      weekday: \"short\",\n      month: \"short\",\n      day: \"2-digit\"\n    }\n  }\n}; // tslint:disable max-classes-per-file\n\nlet NativeDatetimeModule = /*#__PURE__*/(() => {\n  class NativeDatetimeModule {}\n\n  NativeDatetimeModule.ɵfac = function NativeDatetimeModule_Factory(t) {\n    return new (t || NativeDatetimeModule)();\n  };\n\n  NativeDatetimeModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: NativeDatetimeModule\n  });\n  NativeDatetimeModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [{\n      provide: DatetimeAdapter,\n      useClass: NativeDatetimeAdapter\n    }],\n    imports: [[NativeDateModule]]\n  });\n  return NativeDatetimeModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NativeDatetimeModule, {\n    imports: function () {\n      return [NativeDateModule];\n    }\n  });\n})();\n\nconst ɵ0 = MAT_NATIVE_DATETIME_FORMATS;\nlet MatNativeDatetimeModule = /*#__PURE__*/(() => {\n  class MatNativeDatetimeModule {}\n\n  MatNativeDatetimeModule.ɵfac = function MatNativeDatetimeModule_Factory(t) {\n    return new (t || MatNativeDatetimeModule)();\n  };\n\n  MatNativeDatetimeModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MatNativeDatetimeModule\n  });\n  MatNativeDatetimeModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [{\n      provide: MAT_DATETIME_FORMATS,\n      useValue: ɵ0\n    }],\n    imports: [[NativeDatetimeModule, MatNativeDateModule]]\n  });\n  return MatNativeDatetimeModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MatNativeDatetimeModule, {\n    imports: function () {\n      return [NativeDatetimeModule, MatNativeDateModule];\n    }\n  });\n})();\n/**\r\n * This animation fades in the background color and text content of the\r\n * select's options. It is time delayed to occur 100ms after the overlay\r\n * panel has transformed in.\r\n */\n\n\nconst fadeInContent = trigger(\"fadeInContent\", [state(\"showing\", style({\n  opacity: 1\n})), transition(\"void => showing\", [style({\n  opacity: 0\n}), animate(`150ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)`)])]);\nconst slideCalendar = trigger(\"slideCalendar\", [transition(\"* => left\", [animate(180, keyframes([style({\n  transform: \"translateX(100%)\",\n  offset: 0.5\n}), style({\n  transform: \"translateX(-100%)\",\n  offset: 0.51\n}), style({\n  transform: \"translateX(0)\",\n  offset: 1\n})]))]), transition(\"* => right\", [animate(180, keyframes([style({\n  transform: \"translateX(-100%)\",\n  offset: 0.5\n}), style({\n  transform: \"translateX(100%)\",\n  offset: 0.51\n}), style({\n  transform: \"translateX(0)\",\n  offset: 1\n})]))])]);\n/** @docs-private */\n\nfunction createMissingDateImplError(provider) {\n  return Error(`MatDatetimepicker: No provider found for ${provider}. You must import one of the following ` + `modules at your application root: MatNativeDatetimeModule, MatMomentDatetimeModule, or provide a ` + `custom implementation.`);\n}\n\nvar MatDatetimepickerFilterType = /*#__PURE__*/(() => {\n  (function (MatDatetimepickerFilterType) {\n    MatDatetimepickerFilterType[MatDatetimepickerFilterType[\"DATE\"] = 0] = \"DATE\";\n    MatDatetimepickerFilterType[MatDatetimepickerFilterType[\"HOUR\"] = 1] = \"HOUR\";\n    MatDatetimepickerFilterType[MatDatetimepickerFilterType[\"MINUTE\"] = 2] = \"MINUTE\";\n  })(MatDatetimepickerFilterType || (MatDatetimepickerFilterType = {}));\n\n  return MatDatetimepickerFilterType;\n})();\n\n/**\r\n * An internal class that represents the data corresponding to a single calendar cell.\r\n * @docs-private\r\n */\nclass MatDatetimepickerCalendarCell {\n  constructor(value, displayValue, ariaLabel, enabled) {\n    this.value = value;\n    this.displayValue = displayValue;\n    this.ariaLabel = ariaLabel;\n    this.enabled = enabled;\n  }\n\n}\n/**\r\n * An internal component used to display calendar data in a table.\r\n * @docs-private\r\n */\n\n\nlet MatDatetimepickerCalendarBody = /*#__PURE__*/(() => {\n  class MatDatetimepickerCalendarBody {\n    constructor() {\n      /** The number of columns in the table. */\n      this.numCols = 7;\n      /** Whether to allow selection of disabled cells. */\n\n      this.allowDisabledSelection = false;\n      /** The cell number of the active cell in the table. */\n\n      this.activeCell = 0;\n      /** Emits when a new value is selected. */\n\n      this.selectedValueChange = new EventEmitter();\n    }\n    /** The number of blank cells to put at the beginning for the first row. */\n\n\n    get _firstRowOffset() {\n      return this.rows && this.rows.length && this.rows[0].length ? this.numCols - this.rows[0].length : 0;\n    }\n\n    _cellClicked(cell) {\n      if (!this.allowDisabledSelection && !cell.enabled) {\n        return;\n      }\n\n      this.selectedValueChange.emit(cell.value);\n    }\n\n    _isActiveCell(rowIndex, colIndex) {\n      let cellNumber = rowIndex * this.numCols + colIndex; // Account for the fact that the first row may not have as many cells.\n\n      if (rowIndex) {\n        cellNumber -= this._firstRowOffset;\n      }\n\n      return cellNumber === this.activeCell;\n    }\n\n  }\n\n  MatDatetimepickerCalendarBody.ɵfac = function MatDatetimepickerCalendarBody_Factory(t) {\n    return new (t || MatDatetimepickerCalendarBody)();\n  };\n\n  MatDatetimepickerCalendarBody.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MatDatetimepickerCalendarBody,\n    selectors: [[\"\", \"mat-datetimepicker-calendar-body\", \"\"]],\n    hostAttrs: [1, \"mat-datetimepicker-calendar-body\"],\n    inputs: {\n      numCols: \"numCols\",\n      allowDisabledSelection: \"allowDisabledSelection\",\n      activeCell: \"activeCell\",\n      label: \"label\",\n      rows: \"rows\",\n      todayValue: \"todayValue\",\n      selectedValue: \"selectedValue\",\n      labelMinRequiredCells: \"labelMinRequiredCells\"\n    },\n    outputs: {\n      selectedValueChange: \"selectedValueChange\"\n    },\n    attrs: _c0,\n    decls: 2,\n    vars: 2,\n    consts: [[\"aria-hidden\", \"true\", 4, \"ngIf\"], [\"role\", \"row\", 4, \"ngFor\", \"ngForOf\"], [\"aria-hidden\", \"true\"], [1, \"mat-datetimepicker-calendar-body-label\"], [\"role\", \"row\"], [\"aria-hidden\", \"true\", \"class\", \"mat-datetimepicker-calendar-body-label\", 4, \"ngIf\"], [\"class\", \"mat-datetimepicker-calendar-body-cell\", \"role\", \"button\", 3, \"mat-datetimepicker-calendar-body-active\", \"mat-datetimepicker-calendar-body-disabled\", \"click\", 4, \"ngFor\", \"ngForOf\"], [\"aria-hidden\", \"true\", 1, \"mat-datetimepicker-calendar-body-label\"], [\"role\", \"button\", 1, \"mat-datetimepicker-calendar-body-cell\", 3, \"click\"], [1, \"mat-datetimepicker-calendar-body-cell-content\"]],\n    template: function MatDatetimepickerCalendarBody_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵtemplate(0, MatDatetimepickerCalendarBody_tr_0_Template, 3, 2, \"tr\", 0);\n        ɵngcc0.ɵɵtemplate(1, MatDatetimepickerCalendarBody_tr_1_Template, 3, 2, \"tr\", 1);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx._firstRowOffset < ctx.labelMinRequiredCells);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngForOf\", ctx.rows);\n      }\n    },\n    directives: [ɵngcc2.NgIf, ɵngcc2.NgForOf],\n    styles: [\".mat-datetimepicker-calendar-body{font-size:13px;min-width:224px}.mat-datetimepicker-calendar-body-label{padding:7.1428571429% 0 7.1428571429% 7.1428571429%;height:0;line-height:0;color:rgba(0,0,0,.54);transform:translateX(-6px);text-align:left}.mat-datetimepicker-calendar-body-cell{position:relative;width:14.2857142857%;height:0;line-height:0;padding:7.1428571429% 0;text-align:center;outline:none;cursor:pointer}.mat-datetimepicker-calendar-body-disabled{cursor:default;pointer-events:none}.mat-datetimepicker-calendar-body-cell-content{position:absolute;top:5%;left:5%;display:flex;align-items:center;justify-content:center;box-sizing:border-box;width:90%;height:90%;color:rgba(0,0,0,.87);border:1px solid transparent;border-radius:50px}.mat-datetimepicker-calendar-body-disabled>.mat-datetimepicker-calendar-body-cell-content:not(.mat-datetimepicker-calendar-body-selected){color:rgba(0,0,0,.38)}.mat-datetimepicker-calendar-body-active>.mat-datetimepicker-calendar-body-cell-content:not(.mat-datetimepicker-calendar-body-selected),:not(.mat-datetimepicker-calendar-body-disabled):hover>.mat-datetimepicker-calendar-body-cell-content:not(.mat-datetimepicker-calendar-body-selected){background-color:rgba(0,0,0,.12)}.mat-datetimepicker-calendar-body-disabled>.mat-datetimepicker-calendar-body-today:not(.mat-datetimepicker-calendar-body-selected){border-color:rgba(0,0,0,.18)}[dir=rtl] .mat-datetimepicker-calendar-body-label{padding:0 7.1428571429% 0 0;transform:translateX(6px);text-align:right}\"],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return MatDatetimepickerCalendarBody;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/* tslint:disable */\n\n\nconst yearsPerPage = 24;\nconst yearsPerRow = 4;\n/**\r\n * An internal component used to display multiple years in the datepicker.\r\n * @docs-private\r\n */\n\nlet MatDatetimepickerMultiYearView = /*#__PURE__*/(() => {\n  class MatDatetimepickerMultiYearView {\n    constructor(_adapter, _dateFormats) {\n      this._adapter = _adapter;\n      this._dateFormats = _dateFormats;\n      this._userSelection = new EventEmitter();\n      this.type = \"date\";\n      /** Emits when a new month is selected. */\n\n      this.selectedChange = new EventEmitter();\n\n      if (!this._adapter) {\n        throw createMissingDateImplError(\"DatetimeAdapter\");\n      }\n\n      if (!this._dateFormats) {\n        throw createMissingDateImplError(\"MAT_DATETIME_FORMATS\");\n      }\n\n      this._activeDate = this._adapter.today();\n    }\n    /** The date to display in this multi year view*/\n\n\n    get activeDate() {\n      return this._activeDate;\n    }\n\n    set activeDate(value) {\n      let oldActiveDate = this._activeDate;\n      this._activeDate = value || this._adapter.today();\n\n      if (oldActiveDate && this._activeDate && !isSameMultiYearView(this._adapter, oldActiveDate, this._activeDate, this.minDate, this.maxDate)) {\n        this._init();\n      }\n    }\n    /** The currently selected date. */\n\n\n    get selected() {\n      return this._selected;\n    }\n\n    set selected(value) {\n      this._selected = value;\n      this._selectedYear = this._selected && this._adapter.getYear(this._selected);\n    }\n    /** The minimum selectable date. */\n\n\n    get minDate() {\n      return this._minDate;\n    }\n\n    set minDate(value) {\n      this._minDate = this._getValidDateOrNull(this._adapter.deserialize(value));\n    }\n    /** The maximum selectable date. */\n\n\n    get maxDate() {\n      return this._maxDate;\n    }\n\n    set maxDate(value) {\n      this._maxDate = this._getValidDateOrNull(this._adapter.deserialize(value));\n    }\n\n    ngAfterContentInit() {\n      this._init();\n    }\n    /** Handles when a new year is selected. */\n\n\n    _yearSelected(year) {\n      const month = this._adapter.getMonth(this.activeDate);\n\n      const normalizedDate = this._adapter.createDatetime(year, month, 1, 0, 0);\n\n      this.selectedChange.emit(this._adapter.createDatetime(year, month, Math.min(this._adapter.getDate(this.activeDate), this._adapter.getNumDaysInMonth(normalizedDate)), this._adapter.getHour(this.activeDate), this._adapter.getMinute(this.activeDate)));\n\n      if (this.type === \"year\") {\n        this._userSelection.emit();\n      }\n    }\n\n    _getActiveCell() {\n      return getActiveOffset(this._adapter, this.activeDate, this.minDate, this.maxDate);\n    }\n\n    _calendarStateDone() {\n      this._calendarState = \"\";\n    }\n    /** Initializes this year view. */\n\n\n    _init() {\n      this._todayYear = this._adapter.getYear(this._adapter.today());\n      this._yearLabel = this._adapter.getYearName(this.activeDate);\n\n      const activeYear = this._adapter.getYear(this.activeDate);\n\n      const minYearOfPage = activeYear - getActiveOffset(this._adapter, this.activeDate, this.minDate, this.maxDate);\n      this._years = [];\n\n      for (let i = 0, row = []; i < yearsPerPage; i++) {\n        row.push(minYearOfPage + i);\n\n        if (row.length == yearsPerRow) {\n          this._years.push(row.map(year => this._createCellForYear(year)));\n\n          row = [];\n        }\n      }\n    }\n    /** Creates an MatDatetimepickerCalendarCell for the given year. */\n\n\n    _createCellForYear(year) {\n      let yearName = this._adapter.getYearName(this._adapter.createDate(year, 0, 1));\n\n      return new MatDatetimepickerCalendarCell(year, yearName, yearName, this._shouldEnableYear(year));\n    }\n    /** Whether the given year is enabled. */\n\n\n    _shouldEnableYear(year) {\n      // disable if the year is greater than maxDate lower than minDate\n      if (year === undefined || year === null || this.maxDate && year > this._adapter.getYear(this.maxDate) || this.minDate && year < this._adapter.getYear(this.minDate)) {\n        return false;\n      } // enable if it reaches here and there's no filter defined\n\n\n      if (!this.dateFilter) {\n        return true;\n      }\n\n      const firstOfYear = this._adapter.createDate(year, 0, 1); // If any date in the year is enabled count the year as enabled.\n\n\n      for (let date = firstOfYear; this._adapter.getYear(date) == year; date = this._adapter.addCalendarDays(date, 1)) {\n        if (this.dateFilter(date)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n    /**\r\n     * Gets the year in this years range that the given Date falls on.\r\n     * Returns null if the given Date is not in this range.\r\n     */\n\n\n    _getYearInCurrentRange(date) {\n      const year = this._adapter.getYear(date);\n\n      return this._isInRange(year) ? year : null;\n    }\n    /**\r\n     * Validate if the current year is in the current range\r\n     * Returns true if is in range else returns false\r\n     */\n\n\n    _isInRange(year) {\n      return true;\n    }\n    /**\r\n     * @param obj The object to check.\r\n     * @returns The given object if it is both a date instance and valid, otherwise null.\r\n     */\n\n\n    _getValidDateOrNull(obj) {\n      return this._adapter.isDateInstance(obj) && this._adapter.isValid(obj) ? obj : null;\n    }\n\n  }\n\n  MatDatetimepickerMultiYearView.ɵfac = function MatDatetimepickerMultiYearView_Factory(t) {\n    return new (t || MatDatetimepickerMultiYearView)(ɵngcc0.ɵɵdirectiveInject(DatetimeAdapter, 8), ɵngcc0.ɵɵdirectiveInject(MAT_DATETIME_FORMATS, 8));\n  };\n\n  MatDatetimepickerMultiYearView.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MatDatetimepickerMultiYearView,\n    selectors: [[\"mat-datetimepicker-multi-year-view\"]],\n    inputs: {\n      type: \"type\",\n      activeDate: \"activeDate\",\n      selected: \"selected\",\n      minDate: \"minDate\",\n      maxDate: \"maxDate\",\n      dateFilter: \"dateFilter\"\n    },\n    outputs: {\n      _userSelection: \"_userSelection\",\n      selectedChange: \"selectedChange\"\n    },\n    decls: 3,\n    vars: 6,\n    consts: [[1, \"mat-datetimepicker-calendar-table\"], [1, \"mat-datetimepicker-calendar-table-header\"], [\"allowDisabledSelection\", \"true\", \"mat-datetimepicker-calendar-body\", \"\", \"role\", \"grid\", 3, \"activeCell\", \"numCols\", \"rows\", \"selectedValue\", \"todayValue\", \"selectedValueChange\"]],\n    template: function MatDatetimepickerMultiYearView_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"table\", 0);\n        ɵngcc0.ɵɵelement(1, \"thead\", 1);\n        ɵngcc0.ɵɵelementStart(2, \"tbody\", 2);\n        ɵngcc0.ɵɵlistener(\"@slideCalendar.done\", function MatDatetimepickerMultiYearView_Template_tbody_animation_slideCalendar_done_2_listener() {\n          return ctx._calendarStateDone();\n        })(\"selectedValueChange\", function MatDatetimepickerMultiYearView_Template_tbody_selectedValueChange_2_listener($event) {\n          return ctx._yearSelected($event);\n        });\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵproperty(\"@slideCalendar\", ctx._calendarState)(\"activeCell\", ctx._getActiveCell())(\"numCols\", 4)(\"rows\", ctx._years)(\"selectedValue\", ctx._selectedYear)(\"todayValue\", ctx._todayYear);\n      }\n    },\n    directives: [MatDatetimepickerCalendarBody],\n    encapsulation: 2,\n    data: {\n      animation: [slideCalendar]\n    },\n    changeDetection: 0\n  });\n  /** @nocollapse */\n\n  return MatDatetimepickerMultiYearView;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction isSameMultiYearView(dateAdapter, date1, date2, minDate, maxDate) {\n  const year1 = dateAdapter.getYear(date1);\n  const year2 = dateAdapter.getYear(date2);\n  const startingYear = getStartingYear(dateAdapter, minDate, maxDate);\n  return Math.floor((year1 - startingYear) / yearsPerPage) === Math.floor((year2 - startingYear) / yearsPerPage);\n}\n/**\r\n * When the multi-year view is first opened, the active year will be in view.\r\n * So we compute how many years are between the active year and the *slot* where our\r\n * \"startingYear\" will render when paged into view.\r\n */\n\n\nfunction getActiveOffset(dateAdapter, activeDate, minDate, maxDate) {\n  const activeYear = dateAdapter.getYear(activeDate);\n  return euclideanModulo(activeYear - getStartingYear(dateAdapter, minDate, maxDate), yearsPerPage);\n}\n/**\r\n * We pick a \"starting\" year such that either the maximum year would be at the end\r\n * or the minimum year would be at the beginning of a page.\r\n */\n\n\nfunction getStartingYear(dateAdapter, minDate, maxDate) {\n  let startingYear = 0;\n\n  if (maxDate) {\n    const maxYear = dateAdapter.getYear(maxDate);\n    startingYear = maxYear - yearsPerPage + 1;\n  } else if (minDate) {\n    startingYear = dateAdapter.getYear(minDate);\n  }\n\n  return startingYear;\n}\n/** Gets remainder that is non-negative, even if first number is negative */\n\n\nfunction euclideanModulo(a, b) {\n  return (a % b + b) % b;\n}\n/**\r\n * A calendar that is used as part of the datepicker.\r\n * @docs-private\r\n */\n\n\nlet MatDatetimepickerCalendar = /*#__PURE__*/(() => {\n  class MatDatetimepickerCalendar {\n    constructor(_elementRef, _intl, _ngZone, _adapter, _dateFormats, changeDetectorRef) {\n      this._elementRef = _elementRef;\n      this._intl = _intl;\n      this._ngZone = _ngZone;\n      this._adapter = _adapter;\n      this._dateFormats = _dateFormats;\n      this._userSelection = new EventEmitter();\n      /** Active multi year view when click on year. */\n\n      this.multiYearSelector = false;\n      /** Whether the calendar should be started in month or year view. */\n\n      this.startView = \"month\";\n      this.twelvehour = false;\n      this.timeInterval = 1;\n      this.ariaLabel = \"Use arrow keys to navigate\";\n      this.ariaNextMonthLabel = \"Next month\";\n      this.ariaPrevMonthLabel = \"Previous month\";\n      this.ariaNextYearLabel = \"Next year\";\n      this.ariaPrevYearLabel = \"Previous year\";\n      this.ariaNextMultiYearLabel = \"Next year range\";\n      this.ariaPrevMultiYearLabel = \"Previous year range\";\n      /** Prevent user to select same date time */\n\n      this.preventSameDateTimeSelection = false;\n      /** Emits when the currently selected date changes. */\n\n      this.selectedChange = new EventEmitter();\n      /** Emits when the view has been changed. **/\n\n      this.viewChanged = new EventEmitter();\n      this._clockView = \"hour\";\n      this._type = \"date\";\n      /** Date filter for the month and year views. */\n\n      this._dateFilterForViews = date => {\n        return !!date && (!this.dateFilter || this.dateFilter(date, MatDatetimepickerFilterType.DATE)) && (!this.minDate || this._adapter.compareDate(date, this.minDate) >= 0) && (!this.maxDate || this._adapter.compareDate(date, this.maxDate) <= 0);\n      };\n\n      if (!this._adapter) {\n        throw createMissingDateImplError(\"DatetimeAdapter\");\n      }\n\n      if (!this._dateFormats) {\n        throw createMissingDateImplError(\"MAT_DATETIME_FORMATS\");\n      }\n\n      this._intlChanges = _intl.changes.subscribe(() => changeDetectorRef.markForCheck());\n    }\n\n    get type() {\n      return this._type;\n    }\n\n    set type(value) {\n      this._type = value || \"date\";\n\n      if (this.type === \"year\") {\n        this.multiYearSelector = true;\n      }\n    }\n    /** A date representing the period (month or year) to start the calendar in. */\n\n\n    get startAt() {\n      return this._startAt;\n    }\n\n    set startAt(value) {\n      this._startAt = this._adapter.getValidDateOrNull(value);\n    }\n    /** The currently selected date. */\n\n\n    get selected() {\n      return this._selected;\n    }\n\n    set selected(value) {\n      this._selected = this._adapter.getValidDateOrNull(value);\n    }\n    /** The minimum selectable date. */\n\n\n    get minDate() {\n      return this._minDate;\n    }\n\n    set minDate(value) {\n      this._minDate = this._adapter.getValidDateOrNull(value);\n    }\n    /** The maximum selectable date. */\n\n\n    get maxDate() {\n      return this._maxDate;\n    }\n\n    set maxDate(value) {\n      this._maxDate = this._adapter.getValidDateOrNull(value);\n    }\n    /**\r\n     * The current active date. This determines which time period is shown and which date is\r\n     * highlighted when using keyboard navigation.\r\n     */\n\n\n    get _activeDate() {\n      return this._clampedActiveDate;\n    }\n\n    set _activeDate(value) {\n      const oldActiveDate = this._clampedActiveDate;\n      this._clampedActiveDate = this._adapter.clampDate(value, this.minDate, this.maxDate);\n\n      if (oldActiveDate && this._clampedActiveDate && this.currentView === \"month\" && !this._adapter.sameMonthAndYear(oldActiveDate, this._clampedActiveDate)) {\n        if (this._adapter.isInNextMonth(oldActiveDate, this._clampedActiveDate)) {\n          this.calendarState(\"right\");\n        } else {\n          this.calendarState(\"left\");\n        }\n      }\n    }\n\n    get currentView() {\n      return this._currentView;\n    }\n\n    set currentView(view) {\n      this._currentView = view;\n      this.viewChanged.emit(view);\n    }\n    /** The label for the current calendar view. */\n\n\n    get _yearLabel() {\n      return this._adapter.getYearName(this._activeDate);\n    }\n\n    get _monthYearLabel() {\n      if (this.currentView === \"multi-year\") {\n        // The offset from the active year to the \"slot\" for the starting year is the\n        // *actual* first rendered year in the multi-year view, and the last year is\n        // just yearsPerPage - 1 away.\n        const activeYear = this._adapter.getYear(this._activeDate);\n\n        const minYearOfPage = activeYear - getActiveOffset(this._adapter, this._activeDate, this.minDate, this.maxDate);\n        const maxYearOfPage = minYearOfPage + yearsPerPage - 1;\n\n        const minYearName = this._adapter.getYearName(this._adapter.createDate(minYearOfPage, 0, 1));\n\n        const maxYearName = this._adapter.getYearName(this._adapter.createDate(maxYearOfPage, 0, 1));\n\n        return this._intl.formatYearRange(minYearName, maxYearName);\n      }\n\n      return this.currentView === \"month\" ? this._adapter.getMonthNames(\"long\")[this._adapter.getMonth(this._activeDate)] : this._adapter.getYearName(this._activeDate);\n    }\n\n    get _dateLabel() {\n      switch (this.type) {\n        case \"month\":\n          return this._adapter.getMonthNames(\"long\")[this._adapter.getMonth(this._activeDate)];\n\n        default:\n          return this._adapter.format(this._activeDate, this._dateFormats.display.popupHeaderDateLabel);\n      }\n    }\n\n    get _hoursLabel() {\n      let hour = this._adapter.getHour(this._activeDate);\n\n      if (!!this.twelvehour) {\n        if (hour === 0) {\n          hour = 24;\n        }\n\n        hour = hour > 12 ? hour - 12 : hour;\n      }\n\n      return this._2digit(hour);\n    }\n\n    get _minutesLabel() {\n      return this._2digit(this._adapter.getMinute(this._activeDate));\n    }\n\n    get _ariaLabelNext() {\n      switch (this._currentView) {\n        case \"month\":\n          return this.ariaNextMonthLabel;\n\n        case \"year\":\n          return this.ariaNextYearLabel;\n\n        case \"multi-year\":\n          return this.ariaNextMultiYearLabel;\n\n        default:\n          return \"\";\n      }\n    }\n\n    get _ariaLabelPrev() {\n      switch (this._currentView) {\n        case \"month\":\n          return this.ariaPrevMonthLabel;\n\n        case \"year\":\n          return this.ariaPrevYearLabel;\n\n        case \"multi-year\":\n          return this.ariaPrevMultiYearLabel;\n\n        default:\n          return \"\";\n      }\n    }\n\n    _userSelected() {\n      this._userSelection.emit();\n    }\n\n    ngAfterContentInit() {\n      this._activeDate = this.startAt || this._adapter.today();\n\n      this._selectAMPM(this._activeDate);\n\n      this._focusActiveCell();\n\n      if (this.type === \"year\") {\n        this.currentView = \"multi-year\";\n      } else if (this.type === \"month\") {\n        this.currentView = \"year\";\n      } else if (this.type === \"time\") {\n        this.currentView = \"clock\";\n      } else {\n        this.currentView = this.startView || \"month\";\n      }\n    }\n\n    ngOnDestroy() {\n      this._intlChanges.unsubscribe();\n    }\n    /** Handles date selection in the month view. */\n\n\n    _dateSelected(date) {\n      if (this.type === \"date\") {\n        if (!this._adapter.sameDate(date, this.selected) || !this.preventSameDateTimeSelection) {\n          this.selectedChange.emit(date);\n        }\n      } else {\n        this._activeDate = date;\n        this.currentView = \"clock\";\n      }\n    }\n    /** Handles month selection in the year view. */\n\n\n    _monthSelected(month) {\n      if (this.type === \"month\") {\n        if (!this._adapter.sameMonthAndYear(month, this.selected) || !this.preventSameDateTimeSelection) {\n          this.selectedChange.emit(this._adapter.getFirstDateOfMonth(month));\n        }\n      } else {\n        this._activeDate = month;\n        this.currentView = \"month\";\n        this._clockView = \"hour\";\n      }\n    }\n    /** Handles year selection in the multi year view. */\n\n\n    _yearSelected(year) {\n      if (this.type === \"year\") {\n        if (!this._adapter.sameYear(year, this.selected) || !this.preventSameDateTimeSelection) {\n          const normalizedDate = this._adapter.createDatetime(this._adapter.getYear(year), 0, 1, 0, 0);\n\n          this.selectedChange.emit(normalizedDate);\n        }\n      } else {\n        this._activeDate = year;\n        this.currentView = \"year\";\n      }\n    }\n\n    _timeSelected(date) {\n      if (this._clockView !== \"minute\") {\n        this._activeDate = this._updateDate(date);\n        this._clockView = \"minute\";\n      } else {\n        if (!this._adapter.sameDatetime(date, this.selected) || !this.preventSameDateTimeSelection) {\n          this.selectedChange.emit(date);\n        }\n      }\n    }\n\n    _onActiveDateChange(date) {\n      this._activeDate = date;\n    }\n\n    _updateDate(date) {\n      if (!!this.twelvehour) {\n        const HOUR = this._adapter.getHour(date);\n\n        if (HOUR === 12) {\n          if (this._AMPM === \"AM\") {\n            return this._adapter.addCalendarHours(date, -12);\n          }\n        } else if (this._AMPM === \"PM\") {\n          return this._adapter.addCalendarHours(date, 12);\n        }\n      }\n\n      return date;\n    }\n\n    _selectAMPM(date) {\n      if (this._adapter.getHour(date) > 11) {\n        this._AMPM = \"PM\";\n      } else {\n        this._AMPM = \"AM\";\n      }\n    }\n\n    _ampmClicked(source) {\n      if (source === this._AMPM) {\n        return;\n      }\n\n      this._AMPM = source;\n\n      if (this._AMPM === \"AM\") {\n        this._activeDate = this._adapter.addCalendarHours(this._activeDate, -12);\n      } else {\n        this._activeDate = this._adapter.addCalendarHours(this._activeDate, 12);\n      }\n    }\n\n    _yearClicked() {\n      if (this.type === \"year\" || this.multiYearSelector) {\n        this.currentView = \"multi-year\";\n        return;\n      }\n\n      this.currentView = \"year\";\n    }\n\n    _dateClicked() {\n      if (this.type !== \"month\") {\n        this.currentView = \"month\";\n      }\n    }\n\n    _hoursClicked() {\n      this.currentView = \"clock\";\n      this._clockView = \"hour\";\n    }\n\n    _minutesClicked() {\n      this.currentView = \"clock\";\n      this._clockView = \"minute\";\n    }\n    /** Handles user clicks on the previous button. */\n\n\n    _previousClicked() {\n      this._activeDate = this.currentView === \"month\" ? this._adapter.addCalendarMonths(this._activeDate, -1) : this._adapter.addCalendarYears(this._activeDate, this.currentView === \"year\" ? -1 : -yearsPerPage);\n    }\n    /** Handles user clicks on the next button. */\n\n\n    _nextClicked() {\n      this._activeDate = this.currentView === \"month\" ? this._adapter.addCalendarMonths(this._activeDate, 1) : this._adapter.addCalendarYears(this._activeDate, this.currentView === \"year\" ? 1 : yearsPerPage);\n    }\n    /** Whether the previous period button is enabled. */\n\n\n    _previousEnabled() {\n      if (!this.minDate) {\n        return true;\n      }\n\n      return !this.minDate || !this._isSameView(this._activeDate, this.minDate);\n    }\n    /** Whether the next period button is enabled. */\n\n\n    _nextEnabled() {\n      return !this.maxDate || !this._isSameView(this._activeDate, this.maxDate);\n    }\n    /** Handles keydown events on the calendar body. */\n\n\n    _handleCalendarBodyKeydown(event) {\n      // TODO(mmalerba): We currently allow keyboard navigation to disabled dates, but just prevent\n      // disabled ones from being selected. This may not be ideal, we should look into whether\n      // navigation should skip over disabled dates, and if so, how to implement that efficiently.\n      if (this.currentView === \"month\") {\n        this._handleCalendarBodyKeydownInMonthView(event);\n      } else if (this.currentView === \"year\") {\n        this._handleCalendarBodyKeydownInYearView(event);\n      } else if (this.currentView === \"multi-year\") {\n        this._handleCalendarBodyKeydownInMultiYearView(event);\n      } else {\n        this._handleCalendarBodyKeydownInClockView(event);\n      }\n    }\n\n    _focusActiveCell() {\n      this._ngZone.runOutsideAngular(() => {\n        this._ngZone.onStable.asObservable().pipe(first()).subscribe(() => {\n          this._elementRef.nativeElement.focus();\n        });\n      });\n    }\n\n    _calendarStateDone() {\n      this._calendarState = \"\";\n    }\n    /** Whether the two dates represent the same view in the current view mode (month or year). */\n\n\n    _isSameView(date1, date2) {\n      if (this.currentView === \"month\") {\n        return this._adapter.getYear(date1) === this._adapter.getYear(date2) && this._adapter.getMonth(date1) === this._adapter.getMonth(date2);\n      }\n\n      if (this.currentView === \"year\") {\n        return this._adapter.getYear(date1) === this._adapter.getYear(date2);\n      } // Otherwise we are in 'multi-year' view.\n\n\n      return isSameMultiYearView(this._adapter, date1, date2, this.minDate, this.maxDate);\n    }\n    /** Handles keydown events on the calendar body when calendar is in month view. */\n\n\n    _handleCalendarBodyKeydownInMonthView(event) {\n      // tslint:disable-next-line:deprecation\n      switch (event.keyCode) {\n        case LEFT_ARROW:\n          this._activeDate = this._adapter.addCalendarDays(this._activeDate, -1);\n          break;\n\n        case RIGHT_ARROW:\n          this._activeDate = this._adapter.addCalendarDays(this._activeDate, 1);\n          break;\n\n        case UP_ARROW:\n          this._activeDate = this._adapter.addCalendarDays(this._activeDate, -7);\n          break;\n\n        case DOWN_ARROW:\n          this._activeDate = this._adapter.addCalendarDays(this._activeDate, 7);\n          break;\n\n        case HOME:\n          this._activeDate = this._adapter.addCalendarDays(this._activeDate, 1 - this._adapter.getDate(this._activeDate));\n          break;\n\n        case END:\n          this._activeDate = this._adapter.addCalendarDays(this._activeDate, this._adapter.getNumDaysInMonth(this._activeDate) - this._adapter.getDate(this._activeDate));\n          break;\n\n        case PAGE_UP:\n          this._activeDate = event.altKey ? this._adapter.addCalendarYears(this._activeDate, -1) : this._adapter.addCalendarMonths(this._activeDate, -1);\n          break;\n\n        case PAGE_DOWN:\n          this._activeDate = event.altKey ? this._adapter.addCalendarYears(this._activeDate, 1) : this._adapter.addCalendarMonths(this._activeDate, 1);\n          break;\n\n        case ENTER:\n          if (this._dateFilterForViews(this._activeDate)) {\n            this._dateSelected(this._activeDate); // Prevent unexpected default actions such as form submission.\n\n\n            event.preventDefault();\n          }\n\n          return;\n\n        default:\n          // Don't prevent default or focus active cell on keys that we don't explicitly handle.\n          return;\n      } // Prevent unexpected default actions such as form submission.\n\n\n      event.preventDefault();\n    }\n    /** Handles keydown events on the calendar body when calendar is in year view. */\n\n\n    _handleCalendarBodyKeydownInYearView(event) {\n      // tslint:disable-next-line:deprecation\n      switch (event.keyCode) {\n        case LEFT_ARROW:\n          this._activeDate = this._adapter.addCalendarMonths(this._activeDate, -1);\n          break;\n\n        case RIGHT_ARROW:\n          this._activeDate = this._adapter.addCalendarMonths(this._activeDate, 1);\n          break;\n\n        case UP_ARROW:\n          this._activeDate = this._prevMonthInSameCol(this._activeDate);\n          break;\n\n        case DOWN_ARROW:\n          this._activeDate = this._nextMonthInSameCol(this._activeDate);\n          break;\n\n        case HOME:\n          this._activeDate = this._adapter.addCalendarMonths(this._activeDate, -this._adapter.getMonth(this._activeDate));\n          break;\n\n        case END:\n          this._activeDate = this._adapter.addCalendarMonths(this._activeDate, 11 - this._adapter.getMonth(this._activeDate));\n          break;\n\n        case PAGE_UP:\n          this._activeDate = this._adapter.addCalendarYears(this._activeDate, event.altKey ? -10 : -1);\n          break;\n\n        case PAGE_DOWN:\n          this._activeDate = this._adapter.addCalendarYears(this._activeDate, event.altKey ? 10 : 1);\n          break;\n\n        case ENTER:\n          this._monthSelected(this._activeDate);\n\n          break;\n\n        default:\n          // Don't prevent default or focus active cell on keys that we don't explicitly handle.\n          return;\n      } // Prevent unexpected default actions such as form submission.\n\n\n      event.preventDefault();\n    }\n    /** Handles keydown events on the calendar body when calendar is in multi-year view. */\n\n\n    _handleCalendarBodyKeydownInMultiYearView(event) {\n      // tslint:disable-next-line:deprecation\n      switch (event.keyCode) {\n        case LEFT_ARROW:\n          this._activeDate = this._adapter.addCalendarYears(this._activeDate, -1);\n          break;\n\n        case RIGHT_ARROW:\n          this._activeDate = this._adapter.addCalendarYears(this._activeDate, 1);\n          break;\n\n        case UP_ARROW:\n          this._activeDate = this._adapter.addCalendarYears(this._activeDate, -yearsPerRow);\n          break;\n\n        case DOWN_ARROW:\n          this._activeDate = this._adapter.addCalendarYears(this._activeDate, yearsPerRow);\n          break;\n\n        case HOME:\n          this._activeDate = this._adapter.addCalendarYears(this._activeDate, -getActiveOffset(this._adapter, this._activeDate, this.minDate, this.maxDate));\n          break;\n\n        case END:\n          this._activeDate = this._adapter.addCalendarYears(this._activeDate, yearsPerPage - getActiveOffset(this._adapter, this._activeDate, this.minDate, this.maxDate) - 1);\n          break;\n\n        case PAGE_UP:\n          this._activeDate = this._adapter.addCalendarYears(this._activeDate, event.altKey ? -yearsPerPage * 10 : -yearsPerPage);\n          break;\n\n        case PAGE_DOWN:\n          this._activeDate = this._adapter.addCalendarYears(this._activeDate, event.altKey ? yearsPerPage * 10 : yearsPerPage);\n          break;\n\n        case ENTER:\n          this._yearSelected(this._activeDate);\n\n          break;\n\n        default:\n          // Don't prevent default or focus active cell on keys that we don't explicitly handle.\n          return;\n      }\n    }\n    /** Handles keydown events on the calendar body when calendar is in month view. */\n\n\n    _handleCalendarBodyKeydownInClockView(event) {\n      // tslint:disable-next-line:deprecation\n      switch (event.keyCode) {\n        case UP_ARROW:\n          this._activeDate = this._clockView === \"hour\" ? this._adapter.addCalendarHours(this._activeDate, 1) : this._adapter.addCalendarMinutes(this._activeDate, 1);\n          break;\n\n        case DOWN_ARROW:\n          this._activeDate = this._clockView === \"hour\" ? this._adapter.addCalendarHours(this._activeDate, -1) : this._adapter.addCalendarMinutes(this._activeDate, -1);\n          break;\n\n        case ENTER:\n          this._timeSelected(this._activeDate);\n\n          return;\n\n        default:\n          // Don't prevent default or focus active cell on keys that we don't explicitly handle.\n          return;\n      } // Prevent unexpected default actions such as form submission.\n\n\n      event.preventDefault();\n    }\n    /**\r\n     * Determine the date for the month that comes before the given month in the same column in the\r\n     * calendar table.\r\n     */\n\n\n    _prevMonthInSameCol(date) {\n      // Determine how many months to jump forward given that there are 2 empty slots at the beginning\n      // of each year.\n      const increment = this._adapter.getMonth(date) <= 4 ? -5 : this._adapter.getMonth(date) >= 7 ? -7 : -12;\n      return this._adapter.addCalendarMonths(date, increment);\n    }\n    /**\r\n     * Determine the date for the month that comes after the given month in the same column in the\r\n     * calendar table.\r\n     */\n\n\n    _nextMonthInSameCol(date) {\n      // Determine how many months to jump forward given that there are 2 empty slots at the beginning\n      // of each year.\n      const increment = this._adapter.getMonth(date) <= 4 ? 7 : this._adapter.getMonth(date) >= 7 ? 5 : 12;\n      return this._adapter.addCalendarMonths(date, increment);\n    }\n\n    calendarState(direction) {\n      this._calendarState = direction;\n    }\n\n    _2digit(n) {\n      return (\"00\" + n).slice(-2);\n    }\n\n  }\n\n  MatDatetimepickerCalendar.ɵfac = function MatDatetimepickerCalendar_Factory(t) {\n    return new (t || MatDatetimepickerCalendar)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.MatDatepickerIntl), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(DatetimeAdapter, 8), ɵngcc0.ɵɵdirectiveInject(MAT_DATETIME_FORMATS, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef));\n  };\n\n  MatDatetimepickerCalendar.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MatDatetimepickerCalendar,\n    selectors: [[\"mat-datetimepicker-calendar\"]],\n    hostAttrs: [\"role\", \"dialog\", \"tabindex\", \"0\"],\n    hostVars: 3,\n    hostBindings: function MatDatetimepickerCalendar_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"keydown\", function MatDatetimepickerCalendar_keydown_HostBindingHandler($event) {\n          return ctx._handleCalendarBodyKeydown($event);\n        });\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"aria-label\", ctx.ariaLabel);\n        ɵngcc0.ɵɵclassProp(\"mat-datetimepicker-calendar\", true);\n      }\n    },\n    inputs: {\n      multiYearSelector: \"multiYearSelector\",\n      startView: \"startView\",\n      twelvehour: \"twelvehour\",\n      timeInterval: \"timeInterval\",\n      ariaLabel: \"ariaLabel\",\n      ariaNextMonthLabel: \"ariaNextMonthLabel\",\n      ariaPrevMonthLabel: \"ariaPrevMonthLabel\",\n      ariaNextYearLabel: \"ariaNextYearLabel\",\n      ariaPrevYearLabel: \"ariaPrevYearLabel\",\n      ariaNextMultiYearLabel: \"ariaNextMultiYearLabel\",\n      ariaPrevMultiYearLabel: \"ariaPrevMultiYearLabel\",\n      preventSameDateTimeSelection: \"preventSameDateTimeSelection\",\n      type: \"type\",\n      startAt: \"startAt\",\n      selected: \"selected\",\n      minDate: \"minDate\",\n      maxDate: \"maxDate\",\n      dateFilter: \"dateFilter\"\n    },\n    outputs: {\n      _userSelection: \"_userSelection\",\n      selectedChange: \"selectedChange\",\n      viewChanged: \"viewChanged\"\n    },\n    decls: 11,\n    vars: 8,\n    consts: [[1, \"mat-datetimepicker-calendar-header\"], [\"class\", \"mat-datetimepicker-calendar-header-year\", \"role\", \"button\", 3, \"active\", \"click\", 4, \"ngIf\"], [1, \"mat-datetimepicker-calendar-header-date-time\"], [\"class\", \"mat-datetimepicker-calendar-header-date\", \"role\", \"button\", 3, \"active\", \"not-clickable\", \"click\", 4, \"ngIf\"], [\"class\", \"mat-datetimepicker-calendar-header-time\", 3, \"active\", 4, \"ngIf\"], [1, \"mat-datetimepicker-calendar-content\", 3, \"ngSwitch\"], [\"class\", \"mat-month-content\", 4, \"ngIf\"], [3, \"activeDate\", \"dateFilter\", \"selected\", \"type\", \"_userSelection\", \"selectedChange\", 4, \"ngSwitchCase\"], [3, \"activeDate\", \"dateFilter\", \"maxDate\", \"minDate\", \"selected\", \"type\", \"_userSelection\", \"selectedChange\", 4, \"ngSwitchCase\"], [3, \"dateFilter\", \"interval\", \"maxDate\", \"minDate\", \"selected\", \"startView\", \"twelvehour\", \"_userSelection\", \"activeDateChange\", \"selectedChange\", 4, \"ngSwitchDefault\"], [\"role\", \"button\", 1, \"mat-datetimepicker-calendar-header-year\", 3, \"click\"], [4, \"ngIf\"], [\"role\", \"button\", 1, \"mat-datetimepicker-calendar-header-date\", 3, \"click\"], [1, \"mat-datetimepicker-calendar-header-time\"], [\"role\", \"button\", 1, \"mat-datetimepicker-calendar-header-hours\", 3, \"click\"], [\"role\", \"button\", 1, \"mat-datetimepicker-calendar-header-minutes\", 3, \"click\"], [\"class\", \"mat-datetimepicker-calendar-header-ampm-container\", 4, \"ngIf\"], [1, \"mat-datetimepicker-calendar-header-ampm-container\"], [1, \"mat-datetimepicker-calendar-header-ampm\", 3, \"click\"], [1, \"mat-month-content\"], [1, \"mat-datetimepicker-calendar-controls\"], [\"role\", \"button\", 1, \"mat-datetimepicker-calendar-previous-button\", 3, \"click\"], [\"height\", \"24\", \"viewBox\", \"0 0 24 24\", \"width\", \"24\"], [\"d\", \"M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z\"], [1, \"mat-datetimepicker-calendar-period-button\"], [\"role\", \"button\", 1, \"mat-datetimepicker-calendar-next-button\", 3, \"click\"], [\"d\", \"M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z\"], [3, \"activeDate\", \"dateFilter\", \"selected\", \"type\", \"_userSelection\", \"selectedChange\"], [3, \"activeDate\", \"dateFilter\", \"maxDate\", \"minDate\", \"selected\", \"type\", \"_userSelection\", \"selectedChange\"], [3, \"dateFilter\", \"interval\", \"maxDate\", \"minDate\", \"selected\", \"startView\", \"twelvehour\", \"_userSelection\", \"activeDateChange\", \"selectedChange\"]],\n    template: function MatDatetimepickerCalendar_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0);\n        ɵngcc0.ɵɵtemplate(1, MatDatetimepickerCalendar_div_1_Template, 3, 4, \"div\", 1);\n        ɵngcc0.ɵɵelementStart(2, \"div\", 2);\n        ɵngcc0.ɵɵtemplate(3, MatDatetimepickerCalendar_span_3_Template, 2, 5, \"span\", 3);\n        ɵngcc0.ɵɵtemplate(4, MatDatetimepickerCalendar_span_4_Template, 8, 9, \"span\", 4);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementStart(5, \"div\", 5);\n        ɵngcc0.ɵɵtemplate(6, MatDatetimepickerCalendar_div_6_Template, 11, 10, \"div\", 6);\n        ɵngcc0.ɵɵtemplate(7, MatDatetimepickerCalendar_mat_datetimepicker_month_view_7_Template, 1, 4, \"mat-datetimepicker-month-view\", 7);\n        ɵngcc0.ɵɵtemplate(8, MatDatetimepickerCalendar_mat_datetimepicker_year_view_8_Template, 1, 4, \"mat-datetimepicker-year-view\", 7);\n        ɵngcc0.ɵɵtemplate(9, MatDatetimepickerCalendar_mat_datetimepicker_multi_year_view_9_Template, 1, 6, \"mat-datetimepicker-multi-year-view\", 8);\n        ɵngcc0.ɵɵtemplate(10, MatDatetimepickerCalendar_mat_datetimepicker_clock_10_Template, 1, 7, \"mat-datetimepicker-clock\", 9);\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.type !== \"time\");\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.type !== \"time\" && ctx.type !== \"year\");\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.type.endsWith(\"time\"));\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngSwitch\", ctx.currentView);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.currentView === \"month\" || ctx.currentView === \"year\" || ctx.currentView === \"multi-year\");\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngSwitchCase\", \"month\");\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngSwitchCase\", \"year\");\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngSwitchCase\", \"multi-year\");\n      }\n    },\n    directives: function () {\n      return [ɵngcc2.NgIf, ɵngcc2.NgSwitch, ɵngcc2.NgSwitchCase, ɵngcc2.NgSwitchDefault, ɵngcc4.MatIcon, MatDatetimepickerMonthView, MatDatetimepickerYearView, MatDatetimepickerMultiYearView, MatDatetimepickerClock];\n    },\n    styles: [\".mat-datetimepicker-calendar{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;display:block;outline:none}.mat-datetimepicker-calendar[mode=landscape]{display:flex}.mat-datetimepicker-calendar-header{padding:16px;font-size:14px;color:#fff;box-sizing:border-box}[mode=landscape] .mat-datetimepicker-calendar-header{width:150px;min-width:150px}.mat-datetimepicker-calendar-header-date-time,.mat-datetimepicker-calendar-header-year{width:100%;font-weight:500;white-space:nowrap}.mat-datetimepicker-calendar-header-year{font-size:16px}.mat-datetimepicker-calendar-header-year mat-icon{transform:translateY(5px)}.mat-datetimepicker-calendar-header-date-time{font-size:30px;line-height:34px}[mode=landscape] .mat-datetimepicker-calendar-header-date-time{white-space:normal;word-wrap:break-word}.mat-datetimepicker-calendar-header-ampm-container{font-size:.77em}.mat-datetimepicker-calendar-header-ampm:not(.active),.mat-datetimepicker-calendar-header-date:not(.active),.mat-datetimepicker-calendar-header-hours:not(.active),.mat-datetimepicker-calendar-header-minutes:not(.active),.mat-datetimepicker-calendar-header-year:not(.active){cursor:pointer;opacity:.6}.mat-datetimepicker-calendar-header-ampm.not-clickable,.mat-datetimepicker-calendar-header-date.not-clickable,.mat-datetimepicker-calendar-header-hours.not-clickable,.mat-datetimepicker-calendar-header-minutes.not-clickable,.mat-datetimepicker-calendar-header-year.not-clickable{cursor:auto}.mat-datetimepicker-calendar-header-time{padding-left:8px}.mat-datetimepicker-calendar-header-time:not(.active){opacity:.6}.mat-datetimepicker-calendar-header-time:not(.active) .mat-datetimepicker-calendar-header-ampm,.mat-datetimepicker-calendar-header-time:not(.active) .mat-datetimepicker-calendar-header-hours,.mat-datetimepicker-calendar-header-time:not(.active) .mat-datetimepicker-calendar-header-minutes{cursor:pointer;opacity:1}[mode=landscape] .mat-datetimepicker-calendar-header-time{display:block;padding-left:0}.mat-datetimepicker-calendar-content{width:100%;padding:0 8px 8px;outline:none;box-sizing:border-box;overflow:hidden}[mode=landscape] .mat-datetimepicker-calendar-content{padding-top:8px}.mat-datetimepicker-calendar-controls{display:flex;justify-content:space-between}.mat-datetimepicker-calendar-next-button,.mat-datetimepicker-calendar-period-button,.mat-datetimepicker-calendar-previous-button{display:inline-block;height:48px;padding:12px;outline:none;border:0;background:transparent;box-sizing:border-box}.mat-datetimepicker-calendar-next-button,.mat-datetimepicker-calendar-previous-button{width:48px;cursor:pointer}.mat-datetimepicker-calendar-next-button.disabled,.mat-datetimepicker-calendar-previous-button.disabled{color:rgba(0,0,0,.38);pointer-events:none}.mat-datetimepicker-calendar-next-button svg,.mat-datetimepicker-calendar-previous-button svg{fill:currentColor;vertical-align:top}.mat-datetimepicker-calendar-table{border-spacing:0;border-collapse:collapse;width:100%}.mat-datetimepicker-calendar-table-header{color:rgba(0,0,0,.38)}.mat-datetimepicker-calendar-table-header th{text-align:center;font-size:11px;padding:0 0 8px}@media (min-width:480px){.mat-datetimepicker-calendar[mode=auto]{display:flex}.mat-datetimepicker-calendar[mode=auto] .mat-datetimepicker-calendar-header{width:150px;min-width:150px}.mat-datetimepicker-calendar[mode=auto] .mat-datetimepicker-calendar-header-date-time{white-space:normal;word-wrap:break-word}.mat-datetimepicker-calendar[mode=auto] .mat-datetimepicker-calendar-header-time{display:block;padding-left:0}.mat-datetimepicker-calendar[mode=auto] .mat-datetimepicker-calendar-content{padding-top:8px}}\"],\n    encapsulation: 2,\n    data: {\n      animation: [slideCalendar]\n    },\n    changeDetection: 0\n  });\n  /** @nocollapse */\n\n  return MatDatetimepickerCalendar;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/* tslint:disable */\n\n\nconst CLOCK_RADIUS = 50;\nconst CLOCK_INNER_RADIUS = 27.5;\nconst CLOCK_OUTER_RADIUS = 41.25;\nconst CLOCK_TICK_RADIUS = 7.0833;\n/**\r\n * A clock that is used as part of the datepicker.\r\n * @docs-private\r\n */\n\nlet MatDatetimepickerClock = /*#__PURE__*/(() => {\n  class MatDatetimepickerClock {\n    constructor(_element, _adapter) {\n      this._element = _element;\n      this._adapter = _adapter;\n      this._userSelection = new EventEmitter();\n      this.interval = 1;\n      this.twelvehour = false;\n      /** Emits when the currently selected date changes. */\n\n      this.selectedChange = new EventEmitter();\n      this.activeDateChange = new EventEmitter();\n      /** Hours and Minutes representing the clock view. */\n\n      this._hours = [];\n      this._minutes = [];\n      /** Whether the clock is in hour view. */\n\n      this._hourView = true;\n      this._timeChanged = false;\n\n      this.mouseMoveListener = event => {\n        this._handleMousemove(event);\n      };\n\n      this.mouseUpListener = () => {\n        this._handleMouseup();\n      };\n    }\n    /**\r\n     * The date to display in this clock view.\r\n     */\n\n\n    get activeDate() {\n      return this._activeDate;\n    }\n\n    set activeDate(value) {\n      let oldActiveDate = this._activeDate;\n      this._activeDate = this._adapter.clampDate(value, this.minDate, this.maxDate);\n\n      if (!this._adapter.sameMinute(oldActiveDate, this._activeDate)) {\n        this._init();\n      }\n    }\n    /** The currently selected date. */\n\n\n    get selected() {\n      return this._selected;\n    }\n\n    set selected(value) {\n      this._selected = this._adapter.getValidDateOrNull(this._adapter.deserialize(value));\n\n      if (this._selected) {\n        this.activeDate = this._selected;\n      }\n    }\n    /** The minimum selectable date. */\n\n\n    get minDate() {\n      return this._minDate;\n    }\n\n    set minDate(value) {\n      this._minDate = this._adapter.getValidDateOrNull(this._adapter.deserialize(value));\n    }\n    /** The maximum selectable date. */\n\n\n    get maxDate() {\n      return this._maxDate;\n    }\n\n    set maxDate(value) {\n      this._maxDate = this._adapter.getValidDateOrNull(this._adapter.deserialize(value));\n    }\n    /** Whether the clock should be started in hour or minute view. */\n\n\n    set startView(value) {\n      this._hourView = value != \"minute\";\n    }\n\n    get _hand() {\n      let hour = this._adapter.getHour(this.activeDate);\n\n      if (!!this.twelvehour) {\n        if (hour === 0) {\n          hour = 24;\n        }\n\n        this._selectedHour = hour > 12 ? hour - 12 : hour;\n      } else {\n        this._selectedHour = hour;\n      }\n\n      this._selectedMinute = this._adapter.getMinute(this.activeDate);\n      let deg = 0;\n      let radius = CLOCK_OUTER_RADIUS;\n\n      if (this._hourView) {\n        let outer = this._selectedHour > 0 && this._selectedHour < 13;\n        radius = outer ? CLOCK_OUTER_RADIUS : CLOCK_INNER_RADIUS;\n\n        if (this.twelvehour) {\n          radius = CLOCK_OUTER_RADIUS;\n        }\n\n        deg = Math.round(this._selectedHour * (360 / (24 / 2)));\n      } else {\n        deg = Math.round(this._selectedMinute * (360 / 60));\n      }\n\n      return {\n        \"transform\": `rotate(${deg}deg)`,\n        \"height\": `${radius}%`,\n        \"margin-top\": `${50 - radius}%`\n      };\n    }\n\n    ngAfterContentInit() {\n      this.activeDate = this._activeDate || this._adapter.today();\n\n      this._init();\n    }\n    /** Handles mousedown events on the clock body. */\n\n\n    _handleMousedown(event) {\n      this._timeChanged = false;\n      this.setTime(event);\n      document.addEventListener(\"mousemove\", this.mouseMoveListener);\n      document.addEventListener(\"touchmove\", this.mouseMoveListener);\n      document.addEventListener(\"mouseup\", this.mouseUpListener);\n      document.addEventListener(\"touchend\", this.mouseUpListener);\n    }\n\n    _handleMousemove(event) {\n      event.preventDefault();\n      this.setTime(event);\n    }\n\n    _handleMouseup() {\n      document.removeEventListener(\"mousemove\", this.mouseMoveListener);\n      document.removeEventListener(\"touchmove\", this.mouseMoveListener);\n      document.removeEventListener(\"mouseup\", this.mouseUpListener);\n      document.removeEventListener(\"touchend\", this.mouseUpListener);\n\n      if (this._timeChanged) {\n        this.selectedChange.emit(this.activeDate);\n\n        if (!this._hourView) {\n          this._userSelection.emit();\n        }\n      }\n    }\n    /** Initializes this clock view. */\n\n\n    _init() {\n      this._hours.length = 0;\n      this._minutes.length = 0;\n\n      let hourNames = this._adapter.getHourNames();\n\n      let minuteNames = this._adapter.getMinuteNames();\n\n      if (this.twelvehour) {\n        for (let i = 1; i < hourNames.length / 2 + 1; i++) {\n          let radian = i / 6 * Math.PI;\n          let radius = CLOCK_OUTER_RADIUS;\n\n          const date = this._adapter.createDatetime(this._adapter.getYear(this.activeDate), this._adapter.getMonth(this.activeDate), this._adapter.getDate(this.activeDate), i + 1, 0);\n\n          let enabled = (!this.minDate || this._adapter.compareDatetime(date, this.minDate) >= 0) && (!this.maxDate || this._adapter.compareDatetime(date, this.maxDate) <= 0);\n\n          this._hours.push({\n            value: i,\n            displayValue: i === 0 ? \"00\" : hourNames[i],\n            enabled: enabled,\n            top: CLOCK_RADIUS - Math.cos(radian) * radius - CLOCK_TICK_RADIUS,\n            left: CLOCK_RADIUS + Math.sin(radian) * radius - CLOCK_TICK_RADIUS\n          });\n        }\n      } else {\n        for (let i = 0; i < hourNames.length; i++) {\n          let radian = i / 6 * Math.PI;\n          let outer = i > 0 && i < 13,\n              radius = outer ? CLOCK_OUTER_RADIUS : CLOCK_INNER_RADIUS;\n\n          const date = this._adapter.createDatetime(this._adapter.getYear(this.activeDate), this._adapter.getMonth(this.activeDate), this._adapter.getDate(this.activeDate), i, 0);\n\n          let enabled = (!this.minDate || this._adapter.compareDatetime(date, this.minDate, false) >= 0) && (!this.maxDate || this._adapter.compareDatetime(date, this.maxDate, false) <= 0) && (!this.dateFilter || this.dateFilter(date, MatDatetimepickerFilterType.HOUR));\n\n          this._hours.push({\n            value: i,\n            displayValue: i === 0 ? \"00\" : hourNames[i],\n            enabled: enabled,\n            top: CLOCK_RADIUS - Math.cos(radian) * radius - CLOCK_TICK_RADIUS,\n            left: CLOCK_RADIUS + Math.sin(radian) * radius - CLOCK_TICK_RADIUS,\n            fontSize: i > 0 && i < 13 ? \"\" : \"80%\"\n          });\n        }\n      }\n\n      for (let i = 0; i < minuteNames.length; i += 5) {\n        let radian = i / 30 * Math.PI;\n\n        const date = this._adapter.createDatetime(this._adapter.getYear(this.activeDate), this._adapter.getMonth(this.activeDate), this._adapter.getDate(this.activeDate), this._adapter.getHour(this.activeDate), i);\n\n        let enabled = (!this.minDate || this._adapter.compareDatetime(date, this.minDate) >= 0) && (!this.maxDate || this._adapter.compareDatetime(date, this.maxDate) <= 0) && (!this.dateFilter || this.dateFilter(date, MatDatetimepickerFilterType.MINUTE));\n\n        this._minutes.push({\n          value: i,\n          displayValue: i === 0 ? \"00\" : minuteNames[i],\n          enabled: enabled,\n          top: CLOCK_RADIUS - Math.cos(radian) * CLOCK_OUTER_RADIUS - CLOCK_TICK_RADIUS,\n          left: CLOCK_RADIUS + Math.sin(radian) * CLOCK_OUTER_RADIUS - CLOCK_TICK_RADIUS\n        });\n      }\n    }\n    /**\r\n     * Set Time\r\n     * @param event\r\n     */\n\n\n    setTime(event) {\n      let trigger = this._element.nativeElement;\n      let triggerRect = trigger.getBoundingClientRect();\n      let width = trigger.offsetWidth;\n      let height = trigger.offsetHeight;\n      let pageX = event.pageX !== undefined ? event.pageX : event.touches[0].pageX;\n      let pageY = event.pageY !== undefined ? event.pageY : event.touches[0].pageY;\n      let x = width / 2 - (pageX - triggerRect.left - window.pageXOffset);\n      let y = height / 2 - (pageY - triggerRect.top - window.pageYOffset);\n      let radian = Math.atan2(-x, y);\n      let unit = Math.PI / (this._hourView ? 6 : this.interval ? 30 / this.interval : 30);\n      let z = Math.sqrt(x * x + y * y);\n      let outer = this._hourView && z > (width * (CLOCK_OUTER_RADIUS / 100) + width * (CLOCK_INNER_RADIUS / 100)) / 2;\n\n      if (radian < 0) {\n        radian = Math.PI * 2 + radian;\n      }\n\n      let value = Math.round(radian / unit);\n      let date;\n\n      if (this._hourView) {\n        if (this.twelvehour) {\n          value = value === 0 ? 12 : value;\n        } else {\n          if (value === 12) {\n            value = 0;\n          }\n\n          value = outer ? value === 0 ? 12 : value : value === 0 ? 0 : value + 12;\n        }\n\n        date = this._adapter.createDatetime(this._adapter.getYear(this.activeDate), this._adapter.getMonth(this.activeDate), this._adapter.getDate(this.activeDate), value, this._adapter.getMinute(this.activeDate));\n      } else {\n        if (this.interval) {\n          value *= this.interval;\n        }\n\n        if (value === 60) {\n          value = 0;\n        }\n\n        date = this._adapter.createDatetime(this._adapter.getYear(this.activeDate), this._adapter.getMonth(this.activeDate), this._adapter.getDate(this.activeDate), this._adapter.getHour(this.activeDate), value);\n      }\n\n      this._timeChanged = true;\n      this.activeDate = date;\n      this.activeDateChange.emit(this.activeDate);\n    }\n\n  }\n\n  MatDatetimepickerClock.ɵfac = function MatDatetimepickerClock_Factory(t) {\n    return new (t || MatDatetimepickerClock)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DatetimeAdapter));\n  };\n\n  MatDatetimepickerClock.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MatDatetimepickerClock,\n    selectors: [[\"mat-datetimepicker-clock\"]],\n    hostAttrs: [\"role\", \"clock\"],\n    hostBindings: function MatDatetimepickerClock_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"mousedown\", function MatDatetimepickerClock_mousedown_HostBindingHandler($event) {\n          return ctx._handleMousedown($event);\n        });\n      }\n    },\n    inputs: {\n      interval: \"interval\",\n      twelvehour: \"twelvehour\",\n      activeDate: \"activeDate\",\n      selected: \"selected\",\n      minDate: \"minDate\",\n      maxDate: \"maxDate\",\n      startView: \"startView\",\n      dateFilter: \"dateFilter\"\n    },\n    outputs: {\n      _userSelection: \"_userSelection\",\n      selectedChange: \"selectedChange\",\n      activeDateChange: \"activeDateChange\"\n    },\n    decls: 7,\n    vars: 7,\n    consts: [[1, \"mat-datetimepicker-clock\"], [1, \"mat-datetimepicker-clock-center\"], [1, \"mat-datetimepicker-clock-hand\", 3, \"ngStyle\"], [1, \"mat-datetimepicker-clock-hours\"], [\"class\", \"mat-datetimepicker-clock-cell\", 3, \"mat-datetimepicker-clock-cell-disabled\", \"mat-datetimepicker-clock-cell-selected\", \"fontSize\", \"left\", \"top\", 4, \"ngFor\", \"ngForOf\"], [1, \"mat-datetimepicker-clock-minutes\"], [\"class\", \"mat-datetimepicker-clock-cell\", 3, \"mat-datetimepicker-clock-cell-disabled\", \"mat-datetimepicker-clock-cell-selected\", \"left\", \"top\", 4, \"ngFor\", \"ngForOf\"], [1, \"mat-datetimepicker-clock-cell\"]],\n    template: function MatDatetimepickerClock_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0);\n        ɵngcc0.ɵɵelement(1, \"div\", 1);\n        ɵngcc0.ɵɵelement(2, \"div\", 2);\n        ɵngcc0.ɵɵelementStart(3, \"div\", 3);\n        ɵngcc0.ɵɵtemplate(4, MatDatetimepickerClock_div_4_Template, 2, 11, \"div\", 4);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementStart(5, \"div\", 5);\n        ɵngcc0.ɵɵtemplate(6, MatDatetimepickerClock_div_6_Template, 2, 9, \"div\", 6);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵproperty(\"ngStyle\", ctx._hand);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵclassProp(\"active\", ctx._hourView);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngForOf\", ctx._hours);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵclassProp(\"active\", !ctx._hourView);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngForOf\", ctx._minutes);\n      }\n    },\n    directives: [ɵngcc2.NgStyle, ɵngcc2.NgForOf],\n    styles: [\"[_nghost-%COMP%]{position:relative;display:block;min-width:224px;margin:8px;font-size:14px;box-sizing:border-box;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.mat-datetimepicker-clock[_ngcontent-%COMP%]{position:relative;width:100%;height:0;padding-top:100%;background-color:#e0e0e0;border-radius:50%}.mat-datetimepicker-clock-center[_ngcontent-%COMP%]{position:absolute;top:50%;left:50%;width:2%;height:2%;margin:-1%;border-radius:50%}.mat-datetimepicker-clock-hand[_ngcontent-%COMP%]{position:absolute;top:0;right:0;bottom:0;left:0;width:1px;margin:0 auto;transform-origin:bottom}.mat-datetimepicker-clock-hand[_ngcontent-%COMP%]:before{content:\\\"\\\";position:absolute;top:-4px;left:-4px;width:8px;height:8px;border-radius:50%}.mat-datetimepicker-clock-hours[_ngcontent-%COMP%], .mat-datetimepicker-clock-minutes[_ngcontent-%COMP%]{position:absolute;top:0;left:0;width:100%;height:100%;opacity:0;visibility:hidden;transition:.35s;transform:scale(1.2)}.mat-datetimepicker-clock-hours.active[_ngcontent-%COMP%], .mat-datetimepicker-clock-minutes.active[_ngcontent-%COMP%]{opacity:1;visibility:visible;transform:scale(1)}.mat-datetimepicker-clock-minutes[_ngcontent-%COMP%]{transform:scale(.8)}.mat-datetimepicker-clock-cell[_ngcontent-%COMP%]{position:absolute;display:flex;width:14.1666%;height:14.1666%;color:rgba(0,0,0,.87);justify-content:center;box-sizing:border-box;border-radius:50%;align-items:center;cursor:pointer}.mat-datetimepicker-clock-cell[_ngcontent-%COMP%]:not(.mat-datetimepicker-clock-cell-selected):not(.mat-datetimepicker-clock-cell-disabled):hover{background-color:rgba(0,0,0,.1)}.mat-datetimepicker-clock-cell.mat-datetimepicker-clock-cell-disabled[_ngcontent-%COMP%]{color:rgba(0,0,0,.38);pointer-events:none}.mat-datetimepicker-clock-cell.mat-datetimepicker-clock-cell-selected[_ngcontent-%COMP%]{color:#fff}\"]\n  });\n  /** @nocollapse */\n\n  return MatDatetimepickerClock;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** Used to generate a unique ID for each datepicker instance. */\n\n\nlet datetimepickerUid = 0;\n/**\r\n * Component used as the content for the datepicker dialog and popup. We use this instead of using\r\n * MatCalendar directly as the content so we can control the initial focus. This also gives us a\r\n * place to put additional features of the popup that are not part of the calendar itself in the\r\n * future. (e.g. confirmation buttons).\r\n * @docs-private\r\n */\n\nlet MatDatetimepickerContent = /*#__PURE__*/(() => {\n  class MatDatetimepickerContent {\n    ngAfterContentInit() {\n      this._calendar._focusActiveCell();\n    }\n\n    onSelectionChange(date) {\n      this.datetimepicker._select(date);\n\n      this.datetimepicker.close();\n    }\n    /**\r\n     * Handles keydown event on datepicker content.\r\n     * @param event The event.\r\n     */\n\n\n    _handleKeydown(event) {\n      // tslint:disable-next-line:deprecation\n      if (event.keyCode === ESCAPE) {\n        this.datetimepicker.close();\n        event.preventDefault();\n        event.stopPropagation();\n      }\n    }\n\n  }\n\n  MatDatetimepickerContent.ɵfac = function MatDatetimepickerContent_Factory(t) {\n    return new (t || MatDatetimepickerContent)();\n  };\n\n  MatDatetimepickerContent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MatDatetimepickerContent,\n    selectors: [[\"mat-datetimepicker-content\"]],\n    viewQuery: function MatDatetimepickerContent_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(MatDatetimepickerCalendar, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._calendar = _t.first);\n      }\n    },\n    hostAttrs: [1, \"mat-datetimepicker-content\"],\n    hostVars: 2,\n    hostBindings: function MatDatetimepickerContent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"keydown\", function MatDatetimepickerContent_keydown_HostBindingHandler($event) {\n          return ctx._handleKeydown($event);\n        });\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"mat-datetimepicker-content-touch\", ctx.datetimepicker == null ? null : ctx.datetimepicker.touchUi);\n      }\n    },\n    decls: 1,\n    vars: 17,\n    consts: [[\"cdkTrapFocus\", \"\", 1, \"mat-typography\", 3, \"ariaNextMonthLabel\", \"ariaNextYearLabel\", \"ariaPrevMonthLabel\", \"ariaPrevYearLabel\", \"preventSameDateTimeSelection\", \"dateFilter\", \"id\", \"maxDate\", \"minDate\", \"multiYearSelector\", \"selected\", \"startAt\", \"startView\", \"timeInterval\", \"twelvehour\", \"type\", \"_userSelection\", \"selectedChange\", \"viewChanged\"]],\n    template: function MatDatetimepickerContent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"mat-datetimepicker-calendar\", 0);\n        ɵngcc0.ɵɵlistener(\"_userSelection\", function MatDatetimepickerContent_Template_mat_datetimepicker_calendar__userSelection_0_listener() {\n          return ctx.datetimepicker.close();\n        })(\"selectedChange\", function MatDatetimepickerContent_Template_mat_datetimepicker_calendar_selectedChange_0_listener($event) {\n          return ctx.onSelectionChange($event);\n        })(\"viewChanged\", function MatDatetimepickerContent_Template_mat_datetimepicker_calendar_viewChanged_0_listener($event) {\n          return ctx.datetimepicker._viewChanged($event);\n        });\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ariaNextMonthLabel\", ctx.datetimepicker.ariaNextMonthLabel)(\"ariaNextYearLabel\", ctx.datetimepicker.ariaNextYearLabel)(\"ariaPrevMonthLabel\", ctx.datetimepicker.ariaPrevMonthLabel)(\"ariaPrevYearLabel\", ctx.datetimepicker.ariaPrevYearLabel)(\"preventSameDateTimeSelection\", ctx.datetimepicker.preventSameDateTimeSelection)(\"dateFilter\", ctx.datetimepicker._dateFilter)(\"id\", ctx.datetimepicker.id)(\"maxDate\", ctx.datetimepicker._maxDate)(\"minDate\", ctx.datetimepicker._minDate)(\"multiYearSelector\", ctx.datetimepicker.multiYearSelector)(\"selected\", ctx.datetimepicker._selected)(\"startAt\", ctx.datetimepicker.startAt)(\"startView\", ctx.datetimepicker.startView)(\"timeInterval\", ctx.datetimepicker.timeInterval)(\"twelvehour\", ctx.datetimepicker.twelvehour)(\"type\", ctx.datetimepicker.type);\n        ɵngcc0.ɵɵattribute(\"mode\", ctx.datetimepicker.mode);\n      }\n    },\n    directives: [MatDatetimepickerCalendar, ɵngcc5.CdkTrapFocus],\n    styles: [\".mat-datetimepicker-content{box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12);display:block;background-color:#fff;border-radius:2px;overflow:hidden}.mat-datetimepicker-calendar{width:296px;height:405px}.mat-datetimepicker-calendar[mode=landscape]{width:446px;height:328px}@media (min-width:480px){.mat-datetimepicker-calendar[mode=auto]{width:446px;height:328px}}.mat-datetimepicker-content-touch{box-shadow:0 0 0 0 rgba(0,0,0,.2),0 0 0 0 rgba(0,0,0,.14),0 0 0 0 rgba(0,0,0,.12);display:block;box-shadow:0 11px 15px -7px rgba(0,0,0,.2),0 24px 38px 3px rgba(0,0,0,.14),0 9px 46px 8px rgba(0,0,0,.12)}.cdk-global-overlay-wrapper,.cdk-overlay-container{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed;z-index:1000}.cdk-global-overlay-wrapper{display:flex;position:absolute;z-index:1000}.cdk-overlay-pane{box-sizing:border-box}.cdk-overlay-backdrop,.cdk-overlay-pane{position:absolute;pointer-events:auto;z-index:1000}.cdk-overlay-backdrop{top:0;bottom:0;left:0;right:0;transition:opacity .4s cubic-bezier(.25,.8,.25,1);opacity:0}.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:.48}.cdk-overlay-dark-backdrop{background:rgba(0,0,0,.6)}.mat-datetimepicker-dialog .mat-dialog-container{padding:0}\"],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return MatDatetimepickerContent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MatDatetimepicker = /*#__PURE__*/(() => {\n  class MatDatetimepicker {\n    constructor(_dialog, _overlay, _ngZone, _viewContainerRef, _scrollStrategy, _dateAdapter, _dir, _document) {\n      this._dialog = _dialog;\n      this._overlay = _overlay;\n      this._ngZone = _ngZone;\n      this._viewContainerRef = _viewContainerRef;\n      this._scrollStrategy = _scrollStrategy;\n      this._dateAdapter = _dateAdapter;\n      this._dir = _dir;\n      this._document = _document;\n      /** Active multi year view when click on year. */\n\n      this.multiYearSelector = false;\n      /** if true change the clock to 12 hour format. */\n\n      this.twelvehour = false;\n      /** The view that the calendar should start in. */\n\n      this.startView = \"month\";\n      this.mode = \"auto\";\n      this.timeInterval = 1;\n      this.ariaNextMonthLabel = \"Next month\";\n      this.ariaPrevMonthLabel = \"Previous month\";\n      this.ariaNextYearLabel = \"Next year\";\n      this.ariaPrevYearLabel = \"Previous year\";\n      /** Prevent user to select same date time */\n\n      this.preventSameDateTimeSelection = false;\n      /**\r\n       * Emits new selected date when selected date changes.\r\n       * @deprecated Switch to the `dateChange` and `dateInput` binding on the input element.\r\n       */\n\n      this.selectedChanged = new EventEmitter();\n      /** Emits when the datepicker has been opened. */\n      // tslint:disable-next-line:no-output-rename\n\n      this.openedStream = new EventEmitter();\n      /** Emits when the datepicker has been closed. */\n      // tslint:disable-next-line:no-output-rename\n\n      this.closedStream = new EventEmitter();\n      /** Emits when the view has been changed. **/\n\n      this.viewChanged = new EventEmitter();\n      /** Whether the calendar is open. */\n\n      this.opened = false;\n      /** The id for the datepicker calendar. */\n\n      this.id = `mat-datetimepicker-${datetimepickerUid++}`;\n      /** Emits when the datepicker is disabled. */\n\n      this._disabledChange = new Subject();\n      this._validSelected = null;\n      /** The element that was focused before the datepicker was opened. */\n\n      this._focusedElementBeforeOpen = null;\n      this._inputSubscription = Subscription.EMPTY;\n      this._type = \"date\";\n      this._touchUi = false;\n\n      if (!this._dateAdapter) {\n        throw createMissingDateImplError(\"DateAdapter\");\n      }\n    }\n    /** The date to open the calendar to initially. */\n\n\n    get startAt() {\n      // If an explicit startAt is set we start there, otherwise we start at whatever the currently\n      // selected value is.\n      return this._startAt || (this._datepickerInput ? this._datepickerInput.value : null);\n    }\n\n    set startAt(date) {\n      this._startAt = this._dateAdapter.getValidDateOrNull(date);\n    }\n\n    get openOnFocus() {\n      return this._openOnFocus;\n    }\n\n    set openOnFocus(value) {\n      this._openOnFocus = coerceBooleanProperty(value);\n    }\n\n    get type() {\n      return this._type;\n    }\n\n    set type(value) {\n      this._type = value || \"date\";\n    }\n    /**\r\n     * Whether the calendar UI is in touch mode. In touch mode the calendar opens in a dialog rather\r\n     * than a popup and elements have more padding to allow for bigger touch targets.\r\n     */\n\n\n    get touchUi() {\n      return this._touchUi;\n    }\n\n    set touchUi(value) {\n      this._touchUi = coerceBooleanProperty(value);\n    }\n    /** Whether the datepicker pop-up should be disabled. */\n\n\n    get disabled() {\n      return this._disabled === undefined && this._datepickerInput ? this._datepickerInput.disabled : !!this._disabled;\n    }\n\n    set disabled(value) {\n      const newValue = coerceBooleanProperty(value);\n\n      if (newValue !== this._disabled) {\n        this._disabled = newValue;\n\n        this._disabledChange.next(newValue);\n      }\n    }\n    /** The currently selected date. */\n\n\n    get _selected() {\n      return this._validSelected;\n    }\n\n    set _selected(value) {\n      this._validSelected = value;\n    }\n    /** The minimum selectable date. */\n\n\n    get _minDate() {\n      return this._datepickerInput && this._datepickerInput.min;\n    }\n    /** The maximum selectable date. */\n\n\n    get _maxDate() {\n      return this._datepickerInput && this._datepickerInput.max;\n    }\n\n    get _dateFilter() {\n      return this._datepickerInput && this._datepickerInput._dateFilter;\n    }\n\n    _handleFocus() {\n      if (!this.opened && this.openOnFocus) {\n        this.open();\n      }\n    }\n\n    _viewChanged(type) {\n      this.viewChanged.emit(type);\n    }\n\n    ngOnDestroy() {\n      this.close();\n\n      this._inputSubscription.unsubscribe();\n\n      this._disabledChange.complete();\n\n      if (this._popupRef) {\n        this._popupRef.dispose();\n      }\n    }\n    /** Selects the given date */\n\n\n    _select(date) {\n      const oldValue = this._selected;\n      this._selected = date;\n\n      if (!this._dateAdapter.sameDatetime(oldValue, this._selected)) {\n        // tslint:disable-next-line deprecation\n        this.selectedChanged.emit(date);\n      }\n    }\n    /**\r\n     * Register an input with this datepicker.\r\n     * @param input The datepicker input to register with this datepicker.\r\n     */\n\n\n    _registerInput(input) {\n      if (this._datepickerInput) {\n        throw Error(\"A MatDatepicker can only be associated with a single input.\");\n      }\n\n      this._datepickerInput = input;\n      this._inputSubscription = this._datepickerInput._valueChange.subscribe(value => this._selected = value);\n    }\n    /** Open the calendar. */\n\n\n    open() {\n      if (this.opened || this.disabled) {\n        return;\n      }\n\n      if (!this._datepickerInput) {\n        throw Error(\"Attempted to open an MatDatepicker with no associated input.\");\n      }\n\n      if (this._document) {\n        this._focusedElementBeforeOpen = this._document.activeElement;\n      }\n\n      this.touchUi ? this._openAsDialog() : this._openAsPopup();\n      this.opened = true;\n      this.openedStream.emit();\n    }\n    /** Close the calendar. */\n\n\n    close() {\n      if (!this.opened) {\n        return;\n      }\n\n      if (this._popupRef && this._popupRef.hasAttached()) {\n        this._popupRef.detach();\n      }\n\n      if (this._dialogRef) {\n        this._dialogRef.close();\n\n        this._dialogRef = null;\n      }\n\n      if (this._calendarPortal && this._calendarPortal.isAttached) {\n        this._calendarPortal.detach();\n      }\n\n      const completeClose = () => {\n        // The `_opened` could've been reset already if\n        // we got two events in quick succession.\n        if (this.opened) {\n          this.opened = false;\n          this.closedStream.emit();\n          this._focusedElementBeforeOpen = null;\n        }\n      };\n\n      if (this._focusedElementBeforeOpen && typeof this._focusedElementBeforeOpen.focus === \"function\") {\n        // Because IE moves focus asynchronously, we can't count on it being restored before we've\n        // marked the datepicker as closed. If the event fires out of sequence and the element that\n        // we're refocusing opens the datepicker on focus, the user could be stuck with not being\n        // able to close the calendar at all. We work around it by making the logic, that marks\n        // the datepicker as closed, async as well.\n        this._focusedElementBeforeOpen.focus();\n\n        setTimeout(completeClose);\n      } else {\n        completeClose();\n      }\n    }\n    /** Open the calendar as a dialog. */\n\n\n    _openAsDialog() {\n      this._dialogRef = this._dialog.open(MatDatetimepickerContent, {\n        direction: this._dir ? this._dir.value : \"ltr\",\n        viewContainerRef: this._viewContainerRef,\n        panelClass: \"mat-datetimepicker-dialog\"\n      });\n\n      this._dialogRef.afterClosed().subscribe(() => this.close());\n\n      this._dialogRef.componentInstance.datetimepicker = this;\n    }\n    /** Open the calendar as a popup. */\n\n\n    _openAsPopup() {\n      if (!this._calendarPortal) {\n        this._calendarPortal = new ComponentPortal(MatDatetimepickerContent, this._viewContainerRef);\n      }\n\n      if (!this._popupRef) {\n        this._createPopup();\n      }\n\n      if (!this._popupRef.hasAttached()) {\n        const componentRef = this._popupRef.attach(this._calendarPortal);\n\n        componentRef.instance.datetimepicker = this; // Update the position once the calendar has rendered.\n\n        this._ngZone.onStable.asObservable().pipe(first()).subscribe(() => {\n          this._popupRef.updatePosition();\n        });\n      }\n\n      this._popupRef.backdropClick().subscribe(() => this.close());\n    }\n    /** Create the popup. */\n\n\n    _createPopup() {\n      const overlayConfig = new OverlayConfig({\n        positionStrategy: this._createPopupPositionStrategy(),\n        hasBackdrop: true,\n        backdropClass: \"mat-overlay-transparent-backdrop\",\n        direction: this._dir ? this._dir.value : \"ltr\",\n        scrollStrategy: this._scrollStrategy(),\n        panelClass: \"mat-datetimepicker-popup\"\n      });\n      this._popupRef = this._overlay.create(overlayConfig);\n    }\n    /** Create the popup PositionStrategy. */\n\n\n    _createPopupPositionStrategy() {\n      return this._overlay.position().flexibleConnectedTo(this._datepickerInput.getConnectedOverlayOrigin()).withTransformOriginOn(\".mat-datetimepicker-content\").withFlexibleDimensions(false).withViewportMargin(8).withLockedPosition().withPositions([{\n        originX: \"start\",\n        originY: \"bottom\",\n        overlayX: \"start\",\n        overlayY: \"top\"\n      }, {\n        originX: \"start\",\n        originY: \"top\",\n        overlayX: \"start\",\n        overlayY: \"bottom\"\n      }, {\n        originX: \"end\",\n        originY: \"bottom\",\n        overlayX: \"end\",\n        overlayY: \"top\"\n      }, {\n        originX: \"end\",\n        originY: \"top\",\n        overlayX: \"end\",\n        overlayY: \"bottom\"\n      }]);\n    }\n\n  }\n\n  MatDatetimepicker.ɵfac = function MatDatetimepicker_Factory(t) {\n    return new (t || MatDatetimepicker)(ɵngcc0.ɵɵdirectiveInject(ɵngcc6.MatDialog), ɵngcc0.ɵɵdirectiveInject(ɵngcc7.Overlay), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(MAT_DATEPICKER_SCROLL_STRATEGY), ɵngcc0.ɵɵdirectiveInject(DatetimeAdapter, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc8.Directionality, 8), ɵngcc0.ɵɵdirectiveInject(DOCUMENT, 8));\n  };\n\n  MatDatetimepicker.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MatDatetimepicker,\n    selectors: [[\"mat-datetimepicker\"]],\n    inputs: {\n      multiYearSelector: \"multiYearSelector\",\n      twelvehour: \"twelvehour\",\n      startView: \"startView\",\n      mode: \"mode\",\n      timeInterval: \"timeInterval\",\n      ariaNextMonthLabel: \"ariaNextMonthLabel\",\n      ariaPrevMonthLabel: \"ariaPrevMonthLabel\",\n      ariaNextYearLabel: \"ariaNextYearLabel\",\n      ariaPrevYearLabel: \"ariaPrevYearLabel\",\n      preventSameDateTimeSelection: \"preventSameDateTimeSelection\",\n      startAt: \"startAt\",\n      openOnFocus: \"openOnFocus\",\n      type: \"type\",\n      touchUi: \"touchUi\",\n      disabled: \"disabled\",\n      panelClass: \"panelClass\"\n    },\n    outputs: {\n      selectedChanged: \"selectedChanged\",\n      openedStream: \"opened\",\n      closedStream: \"closed\",\n      viewChanged: \"viewChanged\"\n    },\n    exportAs: [\"matDatetimepicker\"],\n    decls: 0,\n    vars: 0,\n    template: function MatDatetimepicker_Template(rf, ctx) {},\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  /** @nocollapse */\n\n  return MatDatetimepicker;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // tslint:disable no-use-before-declare\n\n\nconst MAT_DATETIMEPICKER_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => MatDatetimepickerInput),\n  multi: true\n};\nconst MAT_DATETIMEPICKER_VALIDATORS = {\n  provide: NG_VALIDATORS,\n  useExisting: forwardRef(() => MatDatetimepickerInput),\n  multi: true\n};\n/**\r\n * An event used for datepicker input and change events. We don't always have access to a native\r\n * input or change event because the event may have been triggered by the user clicking on the\r\n * calendar popup. For consistency, we always use MatDatepickerInputEvent instead.\r\n */\n\nclass MatDatetimepickerInputEvent {\n  constructor(target, targetElement) {\n    this.target = target;\n    this.targetElement = targetElement;\n    this.value = this.target.value;\n  }\n\n}\n/** Directive used to connect an input to a MatDatepicker. */\n\n\nlet MatDatetimepickerInput = /*#__PURE__*/(() => {\n  class MatDatetimepickerInput {\n    constructor(_elementRef, _dateAdapter, _dateFormats, _formField) {\n      this._elementRef = _elementRef;\n      this._dateAdapter = _dateAdapter;\n      this._dateFormats = _dateFormats;\n      this._formField = _formField;\n      /** Emits when a `change` event is fired on this `<input>`. */\n\n      this.dateChange = new EventEmitter();\n      /** Emits when an `input` event is fired on this `<input>`. */\n\n      this.dateInput = new EventEmitter();\n      /** Emits when the value changes (either due to user input or programmatic change). */\n\n      this._valueChange = new EventEmitter();\n      /** Emits when the disabled state has changed */\n\n      this._disabledChange = new EventEmitter();\n      this._datepickerSubscription = Subscription.EMPTY;\n      this._localeSubscription = Subscription.EMPTY;\n      /** Whether the last value set on the input was valid. */\n\n      this._lastValueValid = false;\n\n      this._onTouched = () => {};\n\n      this._cvaOnChange = () => {};\n\n      this._validatorOnChange = () => {};\n      /** The form control validator for whether the input parses. */\n\n\n      this._parseValidator = () => {\n        return this._lastValueValid ? null : {\n          \"matDatepickerParse\": {\n            \"text\": this._elementRef.nativeElement.value\n          }\n        };\n      };\n      /** The form control validator for the min date. */\n\n\n      this._minValidator = control => {\n        const controlValue = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(control.value));\n\n        return !this.min || !controlValue || this._dateAdapter.compareDatetime(this.min, controlValue) <= 0 ? null : {\n          \"matDatepickerMin\": {\n            \"min\": this.min,\n            \"actual\": controlValue\n          }\n        };\n      };\n      /** The form control validator for the max date. */\n\n\n      this._maxValidator = control => {\n        const controlValue = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(control.value));\n\n        return !this.max || !controlValue || this._dateAdapter.compareDatetime(this.max, controlValue) >= 0 ? null : {\n          \"matDatepickerMax\": {\n            \"max\": this.max,\n            \"actual\": controlValue\n          }\n        };\n      };\n      /** The form control validator for the date filter. */\n\n\n      this._filterValidator = control => {\n        const controlValue = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(control.value));\n\n        return !this._dateFilter || !controlValue || this._dateFilter(controlValue, MatDatetimepickerFilterType.DATE) ? null : {\n          \"matDatepickerFilter\": true\n        };\n      };\n      /** The combined form control validator for this input. */\n\n\n      this._validator = Validators.compose([this._parseValidator, this._minValidator, this._maxValidator, this._filterValidator]);\n\n      if (!this._dateAdapter) {\n        throw createMissingDateImplError(\"DatetimeAdapter\");\n      }\n\n      if (!this._dateFormats) {\n        throw createMissingDateImplError(\"MAT_DATETIME_FORMATS\");\n      } // Update the displayed date when the locale changes.\n\n\n      this._localeSubscription = _dateAdapter.localeChanges.subscribe(() => {\n        this.value = this.value;\n      });\n    }\n    /** The datepicker that this input is associated with. */\n\n\n    set matDatetimepicker(value) {\n      this.registerDatepicker(value);\n    }\n\n    set matDatepickerFilter(filter) {\n      this._dateFilter = filter;\n\n      this._validatorOnChange();\n    }\n    /** The value of the input. */\n\n\n    get value() {\n      return this._value;\n    }\n\n    set value(value) {\n      value = this._dateAdapter.deserialize(value);\n      this._lastValueValid = !value || this._dateAdapter.isValid(value);\n      value = this._dateAdapter.getValidDateOrNull(value);\n      const oldDate = this.value;\n      this._value = value;\n\n      this._formatValue(value); // use timeout to ensure the datetimepicker is instantiated and we get the correct format\n\n\n      setTimeout(() => {\n        if (!this._dateAdapter.sameDatetime(oldDate, value)) {\n          this._valueChange.emit(value);\n        }\n      });\n    }\n    /** The minimum valid date. */\n\n\n    get min() {\n      return this._min;\n    }\n\n    set min(value) {\n      this._min = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n\n      this._validatorOnChange();\n    }\n    /** The maximum valid date. */\n\n\n    get max() {\n      return this._max;\n    }\n\n    set max(value) {\n      this._max = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n\n      this._validatorOnChange();\n    }\n    /** Whether the datepicker-input is disabled. */\n\n\n    get disabled() {\n      return !!this._disabled;\n    }\n\n    set disabled(value) {\n      const newValue = coerceBooleanProperty(value);\n\n      if (this._disabled !== newValue) {\n        this._disabled = newValue;\n\n        this._disabledChange.emit(newValue);\n      }\n    }\n\n    ngAfterContentInit() {\n      if (this._datepicker) {\n        // tslint:disable-next-line deprecation\n        this._datepickerSubscription = this._datepicker.selectedChanged.subscribe(selected => {\n          this.value = selected;\n\n          this._cvaOnChange(selected);\n\n          this._onTouched();\n\n          this.dateInput.emit(new MatDatetimepickerInputEvent(this, this._elementRef.nativeElement));\n          this.dateChange.emit(new MatDatetimepickerInputEvent(this, this._elementRef.nativeElement));\n        });\n      }\n    }\n\n    ngOnDestroy() {\n      this._datepickerSubscription.unsubscribe();\n\n      this._localeSubscription.unsubscribe();\n\n      this._valueChange.complete();\n\n      this._disabledChange.complete();\n    }\n\n    registerOnValidatorChange(fn) {\n      this._validatorOnChange = fn;\n    }\n\n    validate(c) {\n      return this._validator ? this._validator(c) : null;\n    }\n    /**\r\n     * Gets the element that the datepicker popup should be connected to.\r\n     * @return The element to connect the popup to.\r\n     */\n\n\n    getConnectedOverlayOrigin() {\n      return this._formField ? this._formField.getConnectedOverlayOrigin() : this._elementRef;\n    } // Implemented as part of ControlValueAccessor\n\n\n    writeValue(value) {\n      this.value = value;\n    } // Implemented as part of ControlValueAccessor\n\n\n    registerOnChange(fn) {\n      this._cvaOnChange = fn;\n    } // Implemented as part of ControlValueAccessor\n\n\n    registerOnTouched(fn) {\n      this._onTouched = fn;\n    } // Implemented as part of ControlValueAccessor\n\n\n    setDisabledState(disabled) {\n      this.disabled = disabled;\n    }\n\n    _onKeydown(event) {\n      // tslint:disable-next-line:deprecation\n      if (event.altKey && event.keyCode === DOWN_ARROW) {\n        this._datepicker.open();\n\n        event.preventDefault();\n      }\n    }\n\n    _onInput(value) {\n      let date = this._dateAdapter.parse(value, this.getParseFormat());\n\n      this._lastValueValid = !date || this._dateAdapter.isValid(date);\n      date = this._dateAdapter.getValidDateOrNull(date);\n      this._value = date;\n\n      this._cvaOnChange(date);\n\n      this._valueChange.emit(date);\n\n      this.dateInput.emit(new MatDatetimepickerInputEvent(this, this._elementRef.nativeElement));\n    }\n\n    _onChange() {\n      this.dateChange.emit(new MatDatetimepickerInputEvent(this, this._elementRef.nativeElement));\n    }\n    /** Handles blur events on the input. */\n\n\n    _onBlur() {\n      // Reformat the input only if we have a valid value.\n      if (this.value) {\n        this._formatValue(this.value);\n      }\n\n      this._onTouched();\n    }\n\n    registerDatepicker(value) {\n      if (value) {\n        this._datepicker = value;\n\n        this._datepicker._registerInput(this);\n      }\n    }\n\n    getDisplayFormat() {\n      switch (this._datepicker.type) {\n        case \"date\":\n          return this._dateFormats.display.dateInput;\n\n        case \"datetime\":\n          return this._dateFormats.display.datetimeInput;\n\n        case \"time\":\n          return this._dateFormats.display.timeInput;\n\n        case \"month\":\n          return this._dateFormats.display.monthInput;\n      }\n    }\n\n    getParseFormat() {\n      let parseFormat;\n\n      switch (this._datepicker.type) {\n        case \"date\":\n          parseFormat = this._dateFormats.parse.dateInput;\n          break;\n\n        case \"datetime\":\n          parseFormat = this._dateFormats.parse.datetimeInput;\n          break;\n\n        case \"time\":\n          parseFormat = this._dateFormats.parse.timeInput;\n          break;\n\n        case \"month\":\n          parseFormat = this._dateFormats.parse.monthInput;\n          break;\n      }\n\n      if (!parseFormat) {\n        parseFormat = this._dateFormats.parse.dateInput;\n      }\n\n      return parseFormat;\n    }\n    /** Formats a value and sets it on the input element. */\n\n\n    _formatValue(value) {\n      this._elementRef.nativeElement.value = value ? this._dateAdapter.format(value, this.getDisplayFormat()) : \"\";\n    }\n\n  }\n\n  MatDatetimepickerInput.ɵfac = function MatDatetimepickerInput_Factory(t) {\n    return new (t || MatDatetimepickerInput)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DatetimeAdapter, 8), ɵngcc0.ɵɵdirectiveInject(MAT_DATETIME_FORMATS, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc9.MatFormField, 8));\n  };\n\n  MatDatetimepickerInput.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MatDatetimepickerInput,\n    selectors: [[\"input\", \"matDatetimepicker\", \"\"]],\n    hostVars: 5,\n    hostBindings: function MatDatetimepickerInput_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"focus\", function MatDatetimepickerInput_focus_HostBindingHandler() {\n          return ctx._datepicker._handleFocus();\n        })(\"input\", function MatDatetimepickerInput_input_HostBindingHandler($event) {\n          return ctx._onInput($event.target.value);\n        })(\"change\", function MatDatetimepickerInput_change_HostBindingHandler() {\n          return ctx._onChange();\n        })(\"blur\", function MatDatetimepickerInput_blur_HostBindingHandler() {\n          return ctx._onBlur();\n        })(\"keydown\", function MatDatetimepickerInput_keydown_HostBindingHandler($event) {\n          return ctx._onKeydown($event);\n        });\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵhostProperty(\"disabled\", ctx.disabled);\n        ɵngcc0.ɵɵattribute(\"aria-haspopup\", true)(\"aria-owns\", (ctx._datepicker == null ? null : ctx._datepicker.opened) && ctx._datepicker.id || null)(\"min\", ctx.min ? ctx._dateAdapter.toIso8601(ctx.min) : null)(\"max\", ctx.max ? ctx._dateAdapter.toIso8601(ctx.max) : null);\n      }\n    },\n    inputs: {\n      value: \"value\",\n      matDatetimepicker: \"matDatetimepicker\",\n      matDatepickerFilter: \"matDatepickerFilter\",\n      min: \"min\",\n      max: \"max\",\n      disabled: \"disabled\"\n    },\n    outputs: {\n      dateChange: \"dateChange\",\n      dateInput: \"dateInput\"\n    },\n    exportAs: [\"matDatepickerInput\"],\n    features: [ɵngcc0.ɵɵProvidersFeature([MAT_DATETIMEPICKER_VALUE_ACCESSOR, MAT_DATETIMEPICKER_VALIDATORS, {\n      provide: MAT_INPUT_VALUE_ACCESSOR,\n      useExisting: MatDatetimepickerInput\n    }])]\n  });\n  /** @nocollapse */\n\n  return MatDatetimepickerInput;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MatDatetimepickerToggle = /*#__PURE__*/(() => {\n  class MatDatetimepickerToggle {\n    constructor(_intl, _changeDetectorRef) {\n      this._intl = _intl;\n      this._changeDetectorRef = _changeDetectorRef;\n      this._stateChanges = Subscription.EMPTY;\n    }\n    /** Whether the toggle button is disabled. */\n\n\n    get disabled() {\n      return this._disabled === undefined ? this.datetimepicker.disabled : !!this._disabled;\n    }\n\n    set disabled(value) {\n      this._disabled = coerceBooleanProperty(value);\n    }\n\n    ngOnChanges(changes) {\n      if (changes.datepicker) {\n        this._watchStateChanges();\n      }\n    }\n\n    ngOnDestroy() {\n      this._stateChanges.unsubscribe();\n    }\n\n    ngAfterContentInit() {\n      this._watchStateChanges();\n    }\n\n    _open(event) {\n      if (this.datetimepicker && !this.disabled) {\n        this.datetimepicker.open();\n        event.stopPropagation();\n      }\n    }\n\n    _watchStateChanges() {\n      const datepickerDisabled = this.datetimepicker ? this.datetimepicker._disabledChange : of();\n      const inputDisabled = this.datetimepicker && this.datetimepicker._datepickerInput ? this.datetimepicker._datepickerInput._disabledChange : of();\n\n      this._stateChanges.unsubscribe();\n\n      this._stateChanges = merge([this._intl.changes, datepickerDisabled, inputDisabled]).subscribe(() => this._changeDetectorRef.markForCheck());\n    }\n\n  }\n\n  MatDatetimepickerToggle.ɵfac = function MatDatetimepickerToggle_Factory(t) {\n    return new (t || MatDatetimepickerToggle)(ɵngcc0.ɵɵdirectiveInject(ɵngcc3.MatDatepickerIntl), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef));\n  };\n\n  MatDatetimepickerToggle.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MatDatetimepickerToggle,\n    selectors: [[\"mat-datetimepicker-toggle\"]],\n    hostAttrs: [1, \"mat-datetimepicker-toggle\"],\n    inputs: {\n      disabled: \"disabled\",\n      datetimepicker: [\"for\", \"datetimepicker\"]\n    },\n    exportAs: [\"matDatetimepickerToggle\"],\n    features: [ɵngcc0.ɵɵNgOnChangesFeature],\n    decls: 5,\n    vars: 5,\n    consts: [[\"mat-icon-button\", \"\", \"type\", \"button\", 3, \"disabled\", \"click\"], [3, \"ngSwitch\"], [\"fill\", \"currentColor\", \"focusable\", \"false\", \"height\", \"100%\", \"style\", \"vertical-align: top\", \"viewBox\", \"0 0 24 24\", \"width\", \"100%\", 4, \"ngSwitchCase\"], [\"fill\", \"currentColor\", \"focusable\", \"false\", \"height\", \"100%\", \"style\", \"vertical-align: top\", \"viewBox\", \"0 0 24 24\", \"width\", \"100%\", 4, \"ngSwitchDefault\"], [\"fill\", \"currentColor\", \"focusable\", \"false\", \"height\", \"100%\", \"viewBox\", \"0 0 24 24\", \"width\", \"100%\", 2, \"vertical-align\", \"top\"], [\"d\", \"M12,20A8,8 0 0,0 20,12A8,8 0 0,0 12,4A8,8 0 0,0 4,12A8,8 0 0,0 12,20M12,2A10,10 0 0,1 22,12A10,10 0 0,1 12,22C6.47,22 2,17.5 2,12A10,10 0 0,1 12,2M12.5,7V12.25L17,14.92L16.25,16.15L11,13V7H12.5Z\"], [\"d\", \"M15,13H16.5V15.82L18.94,17.23L18.19,18.53L15,16.69V13M19,8H5V19H9.67C9.24,18.09 9,17.07 9,16A7,7 0 0,1 16,9C17.07,9 18.09,9.24 19,9.67V8M5,21C3.89,21 3,20.1 3,19V5C3,3.89 3.89,3 5,3H6V1H8V3H16V1H18V3H19A2,2 0 0,1 21,5V11.1C22.24,12.36 23,14.09 23,16A7,7 0 0,1 16,23C14.09,23 12.36,22.24 11.1,21H5M16,11.15A4.85,4.85 0 0,0 11.15,16C11.15,18.68 13.32,20.85 16,20.85A4.85,4.85 0 0,0 20.85,16C20.85,13.32 18.68,11.15 16,11.15Z\"], [\"d\", \"M0 0h24v24H0z\", \"fill\", \"none\"], [\"d\", \"M19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11zM7 10h5v5H7z\"]],\n    template: function MatDatetimepickerToggle_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"button\", 0);\n        ɵngcc0.ɵɵlistener(\"click\", function MatDatetimepickerToggle_Template_button_click_0_listener($event) {\n          return ctx._open($event);\n        });\n        ɵngcc0.ɵɵelementStart(1, \"mat-icon\", 1);\n        ɵngcc0.ɵɵtemplate(2, MatDatetimepickerToggle__svg_svg_2_Template, 2, 0, \"svg\", 2);\n        ɵngcc0.ɵɵtemplate(3, MatDatetimepickerToggle__svg_svg_3_Template, 2, 0, \"svg\", 2);\n        ɵngcc0.ɵɵtemplate(4, MatDatetimepickerToggle__svg_svg_4_Template, 3, 0, \"svg\", 3);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"disabled\", ctx.disabled);\n        ɵngcc0.ɵɵattribute(\"aria-label\", ctx._intl.openCalendarLabel);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngSwitch\", ctx.datetimepicker.type);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngSwitchCase\", \"time\");\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngSwitchCase\", \"datetime\");\n      }\n    },\n    directives: [ɵngcc10.MatButton, ɵngcc4.MatIcon, ɵngcc2.NgSwitch, ɵngcc2.NgSwitchCase, ɵngcc2.NgSwitchDefault],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  /** @nocollapse */\n\n  return MatDatetimepickerToggle;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/* tslint:disable */\n\n\nconst DAYS_PER_WEEK = 7;\n/**\r\n * An internal component used to display a single month in the datepicker.\r\n * @docs-private\r\n */\n\nlet MatDatetimepickerMonthView = /*#__PURE__*/(() => {\n  class MatDatetimepickerMonthView {\n    constructor(_adapter, _dateFormats) {\n      this._adapter = _adapter;\n      this._dateFormats = _dateFormats;\n      this.type = \"date\";\n      this._userSelection = new EventEmitter();\n      /** Emits when a new date is selected. */\n\n      this.selectedChange = new EventEmitter();\n\n      if (!this._adapter) {\n        throw createMissingDateImplError(\"DatetimeAdapter\");\n      }\n\n      if (!this._dateFormats) {\n        throw createMissingDateImplError(\"MAT_DATETIME_FORMATS\");\n      }\n\n      const firstDayOfWeek = this._adapter.getFirstDayOfWeek();\n\n      const narrowWeekdays = this._adapter.getDayOfWeekNames(\"narrow\");\n\n      const longWeekdays = this._adapter.getDayOfWeekNames(\"long\"); // Rotate the labels for days of the week based on the configured first day of the week.\n\n\n      let weekdays = longWeekdays.map((long, i) => {\n        return {\n          long,\n          narrow: narrowWeekdays[i]\n        };\n      });\n      this._weekdays = weekdays.slice(firstDayOfWeek).concat(weekdays.slice(0, firstDayOfWeek));\n      this._activeDate = this._adapter.today();\n    }\n    /**\r\n     * The date to display in this month view (everything other than the month and year is ignored).\r\n     */\n\n\n    get activeDate() {\n      return this._activeDate;\n    }\n\n    set activeDate(value) {\n      let oldActiveDate = this._activeDate;\n      this._activeDate = value || this._adapter.today();\n\n      if (oldActiveDate && this._activeDate && !this._adapter.sameMonthAndYear(oldActiveDate, this._activeDate)) {\n        this._init();\n\n        if (this._adapter.isInNextMonth(oldActiveDate, this._activeDate)) {\n          this.calendarState(\"right\");\n        } else {\n          this.calendarState(\"left\");\n        }\n      }\n    }\n    /** The currently selected date. */\n\n\n    get selected() {\n      return this._selected;\n    }\n\n    set selected(value) {\n      this._selected = value;\n      this._selectedDate = this._getDateInCurrentMonth(this.selected);\n    }\n\n    ngAfterContentInit() {\n      this._init();\n    }\n    /** Handles when a new date is selected. */\n\n\n    _dateSelected(date) {\n      this.selectedChange.emit(this._adapter.createDatetime(this._adapter.getYear(this.activeDate), this._adapter.getMonth(this.activeDate), date, this._adapter.getHour(this.activeDate), this._adapter.getMinute(this.activeDate)));\n\n      if (this.type === \"date\") {\n        this._userSelection.emit();\n      }\n    }\n\n    _calendarStateDone() {\n      this._calendarState = \"\";\n    }\n    /** Initializes this month view. */\n\n\n    _init() {\n      this._selectedDate = this._getDateInCurrentMonth(this.selected);\n      this._todayDate = this._getDateInCurrentMonth(this._adapter.today());\n\n      let firstOfMonth = this._adapter.createDatetime(this._adapter.getYear(this.activeDate), this._adapter.getMonth(this.activeDate), 1, this._adapter.getHour(this.activeDate), this._adapter.getMinute(this.activeDate));\n\n      this._firstWeekOffset = (DAYS_PER_WEEK + this._adapter.getDayOfWeek(firstOfMonth) - this._adapter.getFirstDayOfWeek()) % DAYS_PER_WEEK;\n\n      this._createWeekCells();\n    }\n    /** Creates MdCalendarCells for the dates in this month. */\n\n\n    _createWeekCells() {\n      let daysInMonth = this._adapter.getNumDaysInMonth(this.activeDate);\n\n      let dateNames = this._adapter.getDateNames();\n\n      this._weeks = [[]];\n\n      for (let i = 0, cell = this._firstWeekOffset; i < daysInMonth; i++, cell++) {\n        if (cell == DAYS_PER_WEEK) {\n          this._weeks.push([]);\n\n          cell = 0;\n        }\n\n        let date = this._adapter.createDatetime(this._adapter.getYear(this.activeDate), this._adapter.getMonth(this.activeDate), i + 1, this._adapter.getHour(this.activeDate), this._adapter.getMinute(this.activeDate));\n\n        let enabled = !this.dateFilter || this.dateFilter(date);\n\n        let ariaLabel = this._adapter.format(date, this._dateFormats.display.dateA11yLabel);\n\n        this._weeks[this._weeks.length - 1].push(new MatDatetimepickerCalendarCell(i + 1, dateNames[i], ariaLabel, enabled));\n      }\n    }\n    /**\r\n     * Gets the date in this month that the given Date falls on.\r\n     * Returns null if the given Date is in another month.\r\n     */\n\n\n    _getDateInCurrentMonth(date) {\n      return this._adapter.sameMonthAndYear(date, this.activeDate) ? this._adapter.getDate(date) : null;\n    }\n\n    calendarState(direction) {\n      this._calendarState = direction;\n    }\n\n  }\n\n  MatDatetimepickerMonthView.ɵfac = function MatDatetimepickerMonthView_Factory(t) {\n    return new (t || MatDatetimepickerMonthView)(ɵngcc0.ɵɵdirectiveInject(DatetimeAdapter, 8), ɵngcc0.ɵɵdirectiveInject(MAT_DATETIME_FORMATS, 8));\n  };\n\n  MatDatetimepickerMonthView.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MatDatetimepickerMonthView,\n    selectors: [[\"mat-datetimepicker-month-view\"]],\n    inputs: {\n      type: \"type\",\n      activeDate: \"activeDate\",\n      selected: \"selected\",\n      dateFilter: \"dateFilter\"\n    },\n    outputs: {\n      _userSelection: \"_userSelection\",\n      selectedChange: \"selectedChange\"\n    },\n    decls: 5,\n    vars: 6,\n    consts: [[1, \"mat-datetimepicker-calendar-table\"], [1, \"mat-datetimepicker-calendar-table-header\"], [4, \"ngFor\", \"ngForOf\"], [\"mat-datetimepicker-calendar-body\", \"\", \"role\", \"grid\", 3, \"activeCell\", \"rows\", \"selectedValue\", \"todayValue\", \"selectedValueChange\"]],\n    template: function MatDatetimepickerMonthView_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"table\", 0);\n        ɵngcc0.ɵɵelementStart(1, \"thead\", 1);\n        ɵngcc0.ɵɵelementStart(2, \"tr\");\n        ɵngcc0.ɵɵtemplate(3, MatDatetimepickerMonthView_th_3_Template, 2, 2, \"th\", 2);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementStart(4, \"tbody\", 3);\n        ɵngcc0.ɵɵlistener(\"@slideCalendar.done\", function MatDatetimepickerMonthView_Template_tbody_animation_slideCalendar_done_4_listener() {\n          return ctx._calendarStateDone();\n        })(\"selectedValueChange\", function MatDatetimepickerMonthView_Template_tbody_selectedValueChange_4_listener($event) {\n          return ctx._dateSelected($event);\n        });\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵadvance(3);\n        ɵngcc0.ɵɵproperty(\"ngForOf\", ctx._weekdays);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"@slideCalendar\", ctx._calendarState)(\"activeCell\", ctx._adapter.getDate(ctx.activeDate) - 1)(\"rows\", ctx._weeks)(\"selectedValue\", ctx._selectedDate)(\"todayValue\", ctx._todayDate);\n      }\n    },\n    directives: [ɵngcc2.NgForOf, MatDatetimepickerCalendarBody],\n    encapsulation: 2,\n    data: {\n      animation: [slideCalendar]\n    },\n    changeDetection: 0\n  });\n  /** @nocollapse */\n\n  return MatDatetimepickerMonthView;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/* tslint:disable */\n\n/**\r\n * An internal component used to display a single year in the datepicker.\r\n * @docs-private\r\n */\n\n\nlet MatDatetimepickerYearView = /*#__PURE__*/(() => {\n  class MatDatetimepickerYearView {\n    constructor(_adapter, _dateFormats) {\n      this._adapter = _adapter;\n      this._dateFormats = _dateFormats;\n      this._userSelection = new EventEmitter();\n      this.type = \"date\";\n      /** Emits when a new month is selected. */\n\n      this.selectedChange = new EventEmitter();\n\n      if (!this._adapter) {\n        throw createMissingDateImplError(\"DatetimeAdapter\");\n      }\n\n      if (!this._dateFormats) {\n        throw createMissingDateImplError(\"MAT_DATETIME_FORMATS\");\n      }\n\n      this._activeDate = this._adapter.today();\n    }\n    /** The date to display in this year view (everything other than the year is ignored). */\n\n\n    get activeDate() {\n      return this._activeDate;\n    }\n\n    set activeDate(value) {\n      let oldActiveDate = this._activeDate;\n      this._activeDate = value || this._adapter.today();\n\n      if (oldActiveDate && this._activeDate && !this._adapter.sameYear(oldActiveDate, this._activeDate)) {\n        this._init(); // if (oldActiveDate < this._activeDate) {\n        //  this.calendarState('right');\n        // } else {\n        //  this.calendarState('left');\n        // }\n\n      }\n    }\n    /** The currently selected date. */\n\n\n    get selected() {\n      return this._selected;\n    }\n\n    set selected(value) {\n      this._selected = value;\n      this._selectedMonth = this._getMonthInCurrentYear(this.selected);\n    }\n\n    ngAfterContentInit() {\n      this._init();\n    }\n    /** Handles when a new month is selected. */\n\n\n    _monthSelected(month) {\n      const normalizedDate = this._adapter.createDatetime(this._adapter.getYear(this.activeDate), month, 1, 0, 0);\n\n      this.selectedChange.emit(this._adapter.createDatetime(this._adapter.getYear(this.activeDate), month, Math.min(this._adapter.getDate(this.activeDate), this._adapter.getNumDaysInMonth(normalizedDate)), this._adapter.getHour(this.activeDate), this._adapter.getMinute(this.activeDate)));\n\n      if (this.type === \"month\") {\n        this._userSelection.emit();\n      }\n    }\n\n    _calendarStateDone() {\n      this._calendarState = \"\";\n    }\n    /** Initializes this month view. */\n\n\n    _init() {\n      this._selectedMonth = this._getMonthInCurrentYear(this.selected);\n      this._todayMonth = this._getMonthInCurrentYear(this._adapter.today());\n      this._yearLabel = this._adapter.getYearName(this.activeDate);\n\n      let monthNames = this._adapter.getMonthNames(\"short\"); // First row of months only contains 5 elements so we can fit the year label on the same row.\n\n\n      this._months = [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9, 10, 11]].map(row => row.map(month => this._createCellForMonth(month, monthNames[month])));\n    }\n    /**\r\n     * Gets the month in this year that the given Date falls on.\r\n     * Returns null if the given Date is in another year.\r\n     */\n\n\n    _getMonthInCurrentYear(date) {\n      return this._adapter.sameYear(date, this.activeDate) ? this._adapter.getMonth(date) : null;\n    }\n    /** Creates an MdCalendarCell for the given month. */\n\n\n    _createCellForMonth(month, monthName) {\n      let ariaLabel = this._adapter.format(this._adapter.createDatetime(this._adapter.getYear(this.activeDate), month, 1, this._adapter.getHour(this.activeDate), this._adapter.getMinute(this.activeDate)), this._dateFormats.display.monthYearA11yLabel);\n\n      return new MatDatetimepickerCalendarCell(month, monthName.toLocaleUpperCase(), ariaLabel, this._isMonthEnabled(month));\n    } // private calendarState(direction: string): void {\n    //   this._calendarState = direction;\n    // }\n\n    /** Whether the given month is enabled. */\n\n\n    _isMonthEnabled(month) {\n      if (!this.dateFilter) {\n        return true;\n      }\n\n      let firstOfMonth = this._adapter.createDatetime(this._adapter.getYear(this.activeDate), month, 1, this._adapter.getHour(this.activeDate), this._adapter.getMinute(this.activeDate)); // If any date in the month is enabled count the month as enabled.\n\n\n      for (let date = firstOfMonth; this._adapter.getMonth(date) == month; date = this._adapter.addCalendarDays(date, 1)) {\n        if (this.dateFilter(date)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n  }\n\n  MatDatetimepickerYearView.ɵfac = function MatDatetimepickerYearView_Factory(t) {\n    return new (t || MatDatetimepickerYearView)(ɵngcc0.ɵɵdirectiveInject(DatetimeAdapter, 8), ɵngcc0.ɵɵdirectiveInject(MAT_DATETIME_FORMATS, 8));\n  };\n\n  MatDatetimepickerYearView.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MatDatetimepickerYearView,\n    selectors: [[\"mat-datetimepicker-year-view\"]],\n    inputs: {\n      type: \"type\",\n      activeDate: \"activeDate\",\n      selected: \"selected\",\n      dateFilter: \"dateFilter\"\n    },\n    outputs: {\n      _userSelection: \"_userSelection\",\n      selectedChange: \"selectedChange\"\n    },\n    decls: 3,\n    vars: 7,\n    consts: [[1, \"mat-datetimepicker-calendar-table\"], [1, \"mat-datetimepicker-calendar-table-header\"], [\"allowDisabledSelection\", \"true\", \"mat-datetimepicker-calendar-body\", \"\", \"role\", \"grid\", 3, \"activeCell\", \"labelMinRequiredCells\", \"label\", \"rows\", \"selectedValue\", \"todayValue\", \"selectedValueChange\"]],\n    template: function MatDatetimepickerYearView_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"table\", 0);\n        ɵngcc0.ɵɵelement(1, \"thead\", 1);\n        ɵngcc0.ɵɵelementStart(2, \"tbody\", 2);\n        ɵngcc0.ɵɵlistener(\"@slideCalendar.done\", function MatDatetimepickerYearView_Template_tbody_animation_slideCalendar_done_2_listener() {\n          return ctx._calendarStateDone();\n        })(\"selectedValueChange\", function MatDatetimepickerYearView_Template_tbody_selectedValueChange_2_listener($event) {\n          return ctx._monthSelected($event);\n        });\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵproperty(\"@slideCalendar\", ctx._calendarState)(\"activeCell\", ctx._adapter.getMonth(ctx.activeDate))(\"labelMinRequiredCells\", 2)(\"label\", ctx._yearLabel)(\"rows\", ctx._months)(\"selectedValue\", ctx._selectedMonth)(\"todayValue\", ctx._todayMonth);\n      }\n    },\n    directives: [MatDatetimepickerCalendarBody],\n    encapsulation: 2,\n    data: {\n      animation: [slideCalendar]\n    },\n    changeDetection: 0\n  });\n  /** @nocollapse */\n\n  return MatDatetimepickerYearView;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MatDatetimepickerModule = /*#__PURE__*/(() => {\n  class MatDatetimepickerModule {}\n\n  MatDatetimepickerModule.ɵfac = function MatDatetimepickerModule_Factory(t) {\n    return new (t || MatDatetimepickerModule)();\n  };\n\n  MatDatetimepickerModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MatDatetimepickerModule\n  });\n  MatDatetimepickerModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule, MatButtonModule, MatDialogModule, MatIconModule, OverlayModule, A11yModule]]\n  });\n  return MatDatetimepickerModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MatDatetimepickerModule, {\n    declarations: function () {\n      return [MatDatetimepickerCalendar, MatDatetimepickerCalendarBody, MatDatetimepickerClock, MatDatetimepicker, MatDatetimepickerToggle, MatDatetimepickerInput, MatDatetimepickerContent, MatDatetimepickerMonthView, MatDatetimepickerYearView, MatDatetimepickerMultiYearView];\n    },\n    imports: function () {\n      return [CommonModule, MatButtonModule, MatDialogModule, MatIconModule, OverlayModule, A11yModule];\n    },\n    exports: function () {\n      return [MatDatetimepickerCalendar, MatDatetimepickerCalendarBody, MatDatetimepickerClock, MatDatetimepicker, MatDatetimepickerToggle, MatDatetimepickerInput, MatDatetimepickerContent, MatDatetimepickerMonthView, MatDatetimepickerYearView, MatDatetimepickerMultiYearView];\n    }\n  });\n})();\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\n\nexport { CLOCK_INNER_RADIUS, CLOCK_OUTER_RADIUS, CLOCK_RADIUS, CLOCK_TICK_RADIUS, DatetimeAdapter, MAT_DATETIMEPICKER_VALIDATORS, MAT_DATETIMEPICKER_VALUE_ACCESSOR, MAT_DATETIME_FORMATS, MAT_NATIVE_DATETIME_FORMATS, MatDatetimepicker, MatDatetimepickerCalendar, MatDatetimepickerCalendarBody, MatDatetimepickerCalendarCell, MatDatetimepickerClock, MatDatetimepickerContent, MatDatetimepickerFilterType, MatDatetimepickerInput, MatDatetimepickerInputEvent, MatDatetimepickerModule, MatDatetimepickerMonthView, MatDatetimepickerToggle, MatDatetimepickerYearView, MatNativeDatetimeModule, NativeDatetimeAdapter, NativeDatetimeModule, ɵ1, slideCalendar as ɵa, MatDatetimepickerMultiYearView as ɵb }; //# sourceMappingURL=mat-datetimepicker-core.js.map","map":null,"metadata":{},"sourceType":"module"}